{"version":3,"sources":["webpack://nav2d/webpack/universalModuleDefinition","webpack://nav2d/webpack/bootstrap","webpack://nav2d/./node_modules/point-in-polygon/index.js","webpack://nav2d/./node_modules/earcut/src/earcut.js","webpack://nav2d/./node_modules/simple-quadtree/qtree.js","webpack://nav2d/./src/math.js","webpack://nav2d/./node_modules/uuid/dist/esm-browser/rng.js","webpack://nav2d/./node_modules/uuid/dist/esm-browser/regex.js","webpack://nav2d/./node_modules/uuid/dist/esm-browser/stringify.js","webpack://nav2d/./node_modules/uuid/dist/esm-browser/validate.js","webpack://nav2d/./node_modules/uuid/dist/esm-browser/v4.js","webpack://nav2d/./node_modules/tinyqueue/index.js","webpack://nav2d/./src/navmesh.js","webpack://nav2d/./src/nav2d.js"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","point","vs","x","y","inside","j","length","xi","yi","xj","yj","earcut","data","holeIndices","dim","minX","minY","maxX","maxY","invSize","hasHoles","outerLen","outerNode","linkedList","triangles","next","prev","len","start","end","list","queue","steiner","push","getLeftmost","sort","compareX","eliminateHole","filterPoints","eliminateHoles","Math","max","earcutLinked","clockwise","last","signedArea","insertNode","equals","removeNode","again","area","ear","pass","z","zOrder","prevZ","nextZ","q","e","tail","numMerges","pSize","qSize","inSize","sortLinked","indexCurve","stop","isEarHashed","isEar","cureLocalIntersections","splitEarcut","a","b","pointInTriangle","minTX","minTY","maxTX","maxTY","minZ","maxZ","intersects","locallyInside","isValidDiagonal","splitPolygon","hole","hx","hy","qx","Infinity","tan","mx","my","tanMin","abs","sectorContainsSector","findHoleBridge","leftmost","ax","ay","bx","by","cx","cy","px","py","intersectsPolygon","middleInside","p1","p2","q1","q2","o1","sign","o2","o3","o4","onSegment","min","num","a2","Node","b2","an","bp","sum","default","deviation","polygonArea","trianglesArea","flatten","result","vertices","holes","dimensions","holeIndex","w","h","options","isNaN","maxc","leafratio","validate","obj","isequal","createnode","maxchildren","distance","x1","y1","x2","y2","sqrt","overlap_line","buf","dist","dx1","dy1","len1","distancePL","dx","dy","overlap_rect","isleaf","node","leaf","childnode","ni","put_to_nodes","put","update_coords","updatedcoords","w2","h2","ci","overlapfun","strict","callbackOrArray","li","concat","get_rect","get_line","update","attr","orig","splice","remove","count","clear","stringify","strobj","JSON","err","parse","str","Vector","Error","other","_normOther","isclose","acos","clip","dot","angle","cross","PI","eps","v","getRandomValues","crypto","msCrypto","rnds8","Uint8Array","rng","uuid","test","byteToHex","toString","substr","arr","offset","arguments","undefined","toLowerCase","TypeError","rnds","random","TinyQueue","compare","defaultCompare","_down","item","_up","top","bottom","pop","pos","parent","current","halfLength","left","best","right","_normalizePoint","Array","Edge","_uuid","uuidv4","sub","pointVec","parallel","direction","component","otherDirection","otherVec1","otherVec2","collinear","endpoints","onEdge","filter","findIndex","op","squaredLength","Polygon","points","map","bounds","_computeBounds","reduce","acc","add","div","centroid","polyPoints","_toPointArray","edges","edge","otherEdge","shortest","distanceToPoint","minx","miny","NavMesh","polygons","costFunc","heuristicFunc","fromTolerance","toTolerance","_triangulate","pointQuerySize","_buildQuadtree","_buildNeighbors","poly","trianglesIndices","_flatten","indices","slice","flatPoints","qt","QuadTree","boundsSize","polygon","forEach","neighbors","poly1","poly2","portal","_computePortal","_orderClockwise","edge1","edge2","touches","overlap","from","to","path","_findPath","_funnel","fromPoly","_findClosestPolygon","toPoly","frontier","cost","cameFrom","values","nextCost","_computeCost","_heuristic","_reconstructPath","centroidDistance","_computeDistance","halfQuerySize","contains","searchRadius","_findContainingPolygon","containingPoly","closestDistance","closestPoly","console","log","reverse","initialPortal","nextPoly","_extendFunnel","extendLeft","newPoint","apex","lastLeft","_isInClockwiseOrder","k","origin","flip","vec1","vec2","Point"],"mappings":"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","file":"nav2d_deps.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"nav2d\"] = factory();\n\telse\n\t\troot[\"nav2d\"] = factory();\n})((typeof self !== 'undefined' ? self : this), function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","module.exports = function (point, vs) {\n    // ray-casting algorithm based on\n    // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n    \n    var x = point[0], y = point[1];\n    \n    var inside = false;\n    for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {\n        var xi = vs[i][0], yi = vs[i][1];\n        var xj = vs[j][0], yj = vs[j][1];\n        \n        var intersect = ((yi > y) != (yj > y))\n            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n        if (intersect) inside = !inside;\n    }\n    \n    return inside;\n};\n","'use strict';\n\nmodule.exports = earcut;\nmodule.exports.default = earcut;\n\nfunction earcut(data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 1 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    var stop = ear,\n        prev, next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim);\n            triangles.push(ear.i / dim);\n            triangles.push(next.i / dim);\n\n            removeNode(ear);\n\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var p = ear.next.next;\n\n    while (p !== ear.prev) {\n        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // triangle bbox; min & max are calculated like this for speed\n    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),\n        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),\n        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),\n        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);\n\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(minTX, minTY, minX, minY, invSize),\n        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);\n\n    var p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n !== ear.prev && n !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n            area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n !== ear.prev && n !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n            area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i / dim);\n            triangles.push(p.i / dim);\n            triangles.push(b.i / dim);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize);\n                earcutLinked(c, triangles, dim, minX, minY, invSize);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i, len, start, end, list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        eliminateHole(queue[i], outerNode);\n        outerNode = filterPoints(outerNode, outerNode.next);\n    }\n\n    return outerNode;\n}\n\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    outerNode = findHoleBridge(hole, outerNode);\n    if (outerNode) {\n        var b = splitPolygon(outerNode, hole);\n\n        // filter collinear points around the cuts\n        filterPoints(outerNode, outerNode.next);\n        filterPoints(b, b.next);\n    }\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                if (x === hx) {\n                    if (hy === p.y) return p;\n                    if (hy === p.next.y) return p.next;\n                }\n                m = p.x < p.next.x ? p : p.next;\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        mx = m.x,\n        my = m.y,\n        tanMin = Infinity,\n        tan;\n\n    p = m;\n\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if (locallyInside(p, hole) &&\n                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    } while (p !== stop);\n\n    return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = 32767 * (x - minX) * invSize;\n    y = 32767 * (y - minY) * invSize;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&\n           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&\n           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges\n           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    var o1 = sign(area(p1, q1, p2));\n    var o2 = sign(area(p1, q1, q2));\n    var o3 = sign(area(p2, q2, p1));\n    var o4 = sign(area(p2, q2, q1));\n\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n    return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y),\n        b2 = new Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n    // vertex index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertex nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = null;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function (data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (var i = 0, len = holeIndices.length; i < len; i++) {\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    var trianglesArea = 0;\n    for (i = 0; i < triangles.length; i += 3) {\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\n\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for (var i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function (data) {\n    var dim = data[0][0].length,\n        result = {vertices: [], holes: [], dimensions: dim},\n        holeIndex = 0;\n\n    for (var i = 0; i < data.length; i++) {\n        for (var j = 0; j < data[i].length; j++) {\n            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n","/**\n*\n* simple-quadtree is a minimal quadtree implementation that supports simple put, get,\n* remove and clear operations on objects having a x, y position and w, h dimension.\n*\n* Copyright (c) 2013 Antti Saarinen <antti.p.saarinen@gmail.com>\n* https://github.com/asaarinen/qtree\n*\n*/\nfunction QuadTree(x, y, w, h, options) {\n\n    if( typeof x != 'number' || isNaN(x) )\n        x = 0;\n    if( typeof y != 'number' || isNaN(y) )\n        y = 0;\n    if( typeof w != 'number' || isNaN(w) )\n        w = 10;\n    if( typeof h != 'number' || isNaN(h) )\n        h = 10;\n    \n    var maxc = 25;\n    var leafratio = 0.5;\n    if( options ) {\n        if( typeof options.maxchildren == 'number' )\n            if( options.maxchildren > 0 )\n                maxc = options.maxchildren;\n        if( typeof options.leafratio == 'number' )\n            if( options.leafratio >= 0 )\n                leafratio = options.leafratio;\n    }\n\n    // validate an input object\n    function validate(obj) {\n        if( !obj )\n            return false;\n        if( typeof obj.x != 'number' ||\n            typeof obj.y != 'number' ||\n            typeof obj.w != 'number' ||\n            typeof obj.h != 'number' )\n            return false;\n        if( isNaN(obj.x) || isNaN(obj.y) ||\n            isNaN(obj.w) || isNaN(obj.h) )\n            return false;\n        if( obj.w < 0 || obj.h < 0 )\n            return false;\n        return true;\n    }\n\n    // test for deep equality for x,y,w,h\n    function isequal(o1, o2) {\n        if( o1.x == o2.x &&\n            o1.y == o2.y &&\n            o1.w == o2.w &&\n            o1.h == o2.h )\n            return true;\n        return false;\n    }\n\n    // create a new quadtree node\n    function createnode(x, y, w, h) {\n        return {\n            x: x,\n            y: y,\n            w: w,\n            h: h,\n            c: [],\n            l: [],\n            n: []\n        }\n    }\n\n    // root node used by this quadtree\n    var root = createnode(x, y, w, h);\n\n    // calculate distance between two points\n    function distance(x1, y1, x2, y2) {\n        return Math.sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));\n    }\n    \n    // calculate distance between a point and a line (segment)\n    function distancePL(x, y, x1, y1, dx1, dy1, len1 ) {\n        if( !len1 ) // in case length is not provided, assume a line \n            len1 = -1;\n        \n        // x = x1 + s * dx1 + t * dy1\n        // y = y1 + s * dy1 - t * dx1\n        // x * dy1 - y * dx1 = x1 * dy1 - y1 * dx1 + \n        //                     t * ( dy1 * dy1 + dx1 * dx1 )\n        var t = dx1 * dx1 + dy1 * dy1;\n        if( t == 0 )\n            return null;\n        else {\n            t = ( x * dy1 - y * dx1 - x1 * dy1 + y1 * dx1 ) / t;\n            if( Math.abs(dx1) > Math.abs(dy1) )\n                var s = ( x - x1 - t * dy1 ) / dx1;\n            else\n                var s = ( y - y1 + t * dx1 ) / dy1;\n            if( ( s >= 0 && s <= len1 ) || len1 < 0 )\n                return {\n                    s: s,\n                    t: t,\n                    x: x1 + s * dx1,\n                    y: y1 + s * dy1,\n                    dist: Math.abs(t)\n                };\n            else if( s < 0 ) { \n                var dist = distance(x, y, x1, y1);\n                return {\n                    s: s,\n                    dist: dist\n                };\n            } else {\n                var dist = distance(x, y,\n                                    x1 + len1*dx1, \n                                    y1 + len1*dy1);\n                return {\n                    s: s,\n                    dist: dist\n                };\n            }\n        }\n    }\n    \n    // does a line and a rectangle overlap ?\n    function overlap_line(o1, o2, buf) {\n        if( !o1 || !o2 )\n            return true;\n        var dist = distancePL(o2.x + 0.5 * o2.w,\n                              o2.y + 0.5 * o2.h,\n                              o1.x, o1.y, o1.dx, o1.dy, o1.dist);\n        if( dist ) {\n            dist.dist -= buf;\n            if( dist.dist < 0 )\n                return true;\n            if( dist.dist * dist.dist <= o2.w * o2.w + o2.h * o2.h )\n                return true;\n        }\n        return false;\n    }\n\n    // do two rectangles overlap ?\n    function overlap_rect(o1, o2, buf) {\n        if( !o1 || !o2 )\n            return true;\n        if( o1.x + o1.w < o2.x - buf ||\n            o1.y + o1.h < o2.y - buf ||\n            o1.x - buf > o2.x + o2.w ||\n            o1.y - buf > o2.y + o2.h )\n            return false;\n        return true;\n    }\n\n    function isleaf(node, obj) {\n\n        var leaf = false;\n        if( obj.w * obj.h > node.w * node.h * leafratio )\n            leaf = true;\n\n        if( obj.x < node.x ||\n            obj.y < node.y ||\n            obj.x + obj.w > node.x + node.w ||\n            obj.y + obj.h > node.y + node.h )\n            leaf = true;\n\n        var childnode = null;\n        for( var ni = 0; ni < node.n.length; ni++ )\n            if( overlap_rect(obj, node.n[ni], 0) ) {\n                if( childnode ) { // multiple hits\n                    leaf = true;\n                    break;\n                } else\n                    childnode = node.n[ni];\n            }\n        \n        return { leaf: leaf,\n                 childnode: childnode };\n    }\n\n    // put an object to one of the child nodes of this node\n    function put_to_nodes(node, obj) {\n        var leaf = isleaf(node, obj);\n        if( leaf.leaf )\n            node.l.push(obj);\n        else if( leaf.childnode )\n            put(leaf.childnode, obj);\n        else\n            return;\n    }\n    \n    function update_coords(obj, updatedcoords) {\n        obj.x = ((typeof updatedcoords.x == 'number') ? updatedcoords.x : obj.x);\n        obj.y = ((typeof updatedcoords.y == 'number') ? updatedcoords.y : obj.y);\n        obj.w = ((typeof updatedcoords.w == 'number') ? updatedcoords.w : obj.w);\n        obj.h = ((typeof updatedcoords.h == 'number') ? updatedcoords.h : obj.h);\n    }\n\n    function update(node, obj, attr, updatedcoords) {\n        if( typeof attr == 'object' && typeof updatedcoords == 'undefined' ) {\n            updatedcoords = attr;\n            attr = false;\n        }\n\n        if( !validate(obj) || typeof updatedcoords == 'undefined' )\n            return false;\n\n        if( !attr )\n            attr = false;\n        else if( typeof attr != 'string' )\n            attr = 'id';\n\n        var count = 0;\n        for( var ci = 0; ci < node.c.length; ci++ )\n            if( ( attr && node.c[ci][attr] == obj[attr] ) ||\n                ( !attr && isequal(node.c[ci], obj) ) ) {\n\n                // found the object to be updated\n                var orig = node.c[ci];\n                update_coords(orig, updatedcoords);\n                \n                if( orig.x > node.x + node.w ||\n                    orig.y > node.y + node.h ||\n                    orig.x + orig.w < node.x ||\n                    orig.y + orig.h < node.y ) {\n\n                    // this object needs to be removed and added\n                    node.c.splice(ci, 1);\n                    put(root, orig);\n                } // updated object is still inside same node\n                \n                return true;\n            }\n        \n        for( var ci = 0; ci < node.l.length; ci++ )\n            if( ( attr && node.l[ci][attr] == obj[attr] ) ||\n                ( !attr && isequal(node.l[ci], obj) ) ) {\n                \n                var orig = node.l[ci];\n                update_coords(orig, updatedcoords);\n                \n                // found the object to be updated\n                if( orig.x > node.x + node.w ||\n                    orig.y > node.y + node.h ||\n                    orig.x + orig.w < node.x ||\n                    orig.y + orig.h < node.y ) {\n\n                    // this object needs to be removed and added \n                    node.l.splice(ci, 1);\n                    put(root, orig);\n                } // updated object is still inside same node\n                \n                return true;\n            }\n\n        var leaf = isleaf(node, obj);\n        if( !leaf.leaf && leaf.childnode )\n            if( update(leaf.childnode, obj, attr) )\n                return true;\n        return false;\n    }\n\n    // remove an object from this node\n    function remove(node, obj, attr) {\n        if( !validate(obj) )\n            return 0;\n\n        if( !attr )\n            attr = false;\n        else if( typeof attr != 'string' )\n            attr = 'id';\n\n        var count = 0;\n        for( var ci = 0; ci < node.c.length; ci++ )\n            if( ( attr && node.c[ci][attr] == obj[attr] ) ||\n                ( !attr && isequal(node.c[ci], obj) ) ) {\n                count++;\n                node.c.splice(ci, 1);\n                ci--;\n            }\n\n        for( var ci = 0; ci < node.l.length; ci++ )\n            if( ( attr && node.l[ci][attr] == obj[attr] ) ||\n                ( !attr && isequal(node.l[ci], obj) ) ) {\n                count++;\n                node.l.splice(ci, 1);\n                ci--;\n            }\n\n        var leaf = isleaf(node, obj);\n        if( !leaf.leaf && leaf.childnode )\n            return count + remove(leaf.childnode, obj, attr);\n        return count;\n    }\n\n    // put an object to this node\n    function put(node, obj) {\n\n        if( !validate(obj) )\n            return;\n\n        if( node.n.length == 0 ) {\n            node.c.push(obj);\n            \n            // subdivide\n            if( node.c.length > maxc ) {\n                var w2 = node.w / 2;\n                var h2 = node.h / 2;\n                node.n.push(createnode(node.x, node.y, w2, h2),\n                            createnode(node.x + w2, node.y, w2, h2),\n                            createnode(node.x, node.y + h2, w2, h2),\n                            createnode(node.x + w2, node.y + h2, w2, h2));\n                for( var ci = 0; ci < node.c.length; ci++ ) \n                    put_to_nodes(node, node.c[ci]);\n                node.c = [];\n            }\n        } else \n            put_to_nodes(node, obj);\n    }\n\n    // iterate through all objects in this node matching given overlap\n    // function\n    function getter(overlapfun, node, obj, buf, strict, callbackOrArray) {\n        for( var li = 0; li < node.l.length; li++ )\n            if( !strict || overlapfun(obj, node.l[li], buf) )\n                if( typeof callbackOrArray == 'object' )\n                    callbackOrArray.push(node.l[li]);\n                else if( !callbackOrArray(node.l[li]) )\n                    return false;\n        for( var li = 0; li < node.c.length; li++ )\n            if( !strict || overlapfun(obj, node.c[li], buf) )\n                if( typeof callbackOrArray == 'object' )\n                    callbackOrArray.push(node.c[li]);\n                else if( !callbackOrArray(node.c[li]) )\n                    return false;\n        for( var ni = 0; ni < node.n.length; ni++ ) {\n            if( overlapfun(obj, node.n[ni], buf) ) {\n                if( typeof callbackOrArray == 'object' )\n                    callbackOrArray.concat(getter(overlapfun, node.n[ni], obj, buf, strict, callbackOrArray));\n                else if( !getter(overlapfun, node.n[ni], obj, buf, strict, callbackOrArray) )\n                    return false;\n            }\n        }\n        return true;\n    }\n\n    // iterate through all objects in this node matching the given rectangle\n    function get_rect(node, obj, buf, callbackOrArray) {\n        return getter(overlap_rect, node, obj, buf, true, callbackOrArray);\n    }\n\n    // iterate through all objects in this node matching the given\n    // line (segment)\n    function get_line(node, obj, buf, callbackOrArray) {\n        return getter(overlap_line, node, obj, buf, false, callbackOrArray);\n    }\n\n    // iterate through all objects in this node matching given\n    // geometry, either a rectangle or a line segment\n    function get(node, obj, buf, callbackOrArray) {\n\n        if( (typeof buf == 'function' || typeof buf == 'object') && typeof callbackOrArray == 'undefined' ) {\n            callbackOrArray = buf;\n            buf = 0;\n        }\n        if( typeof callbackOrArray == 'undefined' ) {\n            callbackOrArray = [];\n            buf = 0;\n        }\n        if( obj == null )\n            get_rect(node, obj, buf, callbackOrArray);\n        else if( typeof obj.x == 'number' &&\n                 typeof obj.y == 'number' &&\n                 !isNaN(obj.x) && !isNaN(obj.y) ) {\n            if( typeof obj.dx == 'number' &&\n                typeof obj.dy == 'number' &&\n                !isNaN(obj.dx) && !isNaN(obj.dy) )\n                get_line(node, obj, buf, callbackOrArray);\n            else if( typeof obj.w == 'number' &&\n                     typeof obj.h == 'number' &&\n                     !isNaN(obj.w) && !isNaN(obj.h) )\n                get_rect(node, obj, buf, callbackOrArray);\n        }\n        if( typeof callbackOrArray == 'object' ) \n            return callbackOrArray;\n    }\n\n    // return the object interface\n    return {\n        get: function(obj, buf, callbackOrArray) {\n            return get(root, obj, buf, callbackOrArray);\n        },\n        put: function(obj) {\n            put(root, obj);\n        },\n        update: function(obj, attr, updatedcoords) {\n            return update(root, obj, attr, updatedcoords);\n        },\n        remove: function(obj, attr) {\n            return remove(root, obj, attr);\n        },\n        clear: function() {\n            root = createnode(x, y, w, h);\n        },\n        stringify: function() {\n            var strobj = {\n                x: x, y: y, w: w, h: h,\n                maxc: maxc, \n                leafratio: leafratio,\n                root: root\n            };\n            try {\n                return JSON.stringify(strobj);\n            } catch(err) {\n                // could not stringify\n                // probably due to objects included in qtree being non-stringifiable\n                return null; \n            }\n        },\n        parse: function(str) {\n            if( typeof str == 'string' )\n                str = JSON.parse(str);\n            \n            x = str.x;\n            y = str.y;\n            w = str.w;\n            h = str.h;\n            maxc = str.maxc;\n            leafratio = str.leafratio;\n            root = str.root;\n        }\n    };\n}\n\n// for use within node.js\nif( typeof module != 'undefined' )\n    module.exports = QuadTree;\n","export const EPS = 1e-8;\n\nexport class Vector {\n    constructor(x, y) {\n        if (typeof x !== \"number\" || typeof y !== \"number\") {\n            throw new Error(\"Vector components must be numbers.\");\n        }\n\n        this.x = x;\n        this.y = y;\n    }\n\n    _normOther(other) {\n        if (typeof other == \"number\") {\n            return new Vector(other, other);\n        }\n        return other;\n    }\n\n    add(other) {\n        other = this._normOther(other);\n        return new Vector(this.x + other.x, this.y + other.y);\n    }\n\n    sub(other) {\n        other = this._normOther(other);\n        return new Vector(this.x - other.x, this.y - other.y);\n    }\n\n    mul(other) {\n        other = this._normOther(other);\n        return new Vector(this.x * other.x, this.y * other.y);\n    }\n\n    div(other) {\n        other = this._normOther(other);\n        return new Vector(this.x / other.x, this.y / other.y);\n    }\n\n    length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n\n    equals(other) {\n        return isclose(this.x, other.x) && isclose(this.y, other.y);\n    }\n\n    angle(other) {\n        return Math.acos(\n            clip(-1, 1, dot(this, other) / (this.length() * other.length()))\n        );\n    }\n\n    counterclockwiseAngle(other) {\n        const angle = this.angle(other);\n        return cross(this, other) >= 0 ? angle : 2 * Math.PI - angle;\n    }\n\n    toString() {\n        return `{ x: ${this.x}, y: ${this.y} }`;\n    }\n}\n\nexport function dot(a, b) {\n    return a.x * b.x + a.y * b.y;\n}\n\nexport function cross(a, b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nexport function isclose(a, b, eps = EPS) {\n    return a > b - eps && a < b + eps;\n}\n\nexport function clip(a, b, v) {\n    if (v < a) return a;\n    if (v > b) return b;\n    return v;\n}\n","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n// find the complete implementation of crypto (msCrypto) on IE11.\nvar getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);\nvar rnds8 = new Uint8Array(16);\nexport default function rng() {\n  if (!getRandomValues) {\n    throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n  }\n\n  return getRandomValues(rnds8);\n}","export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","import REGEX from './regex.js';\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n\nexport default validate;","import rng from './rng.js';\nimport stringify from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return stringify(rnds);\n}\n\nexport default v4;","\nexport default class TinyQueue {\n    constructor(data = [], compare = defaultCompare) {\n        this.data = data;\n        this.length = this.data.length;\n        this.compare = compare;\n\n        if (this.length > 0) {\n            for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);\n        }\n    }\n\n    push(item) {\n        this.data.push(item);\n        this.length++;\n        this._up(this.length - 1);\n    }\n\n    pop() {\n        if (this.length === 0) return undefined;\n\n        const top = this.data[0];\n        const bottom = this.data.pop();\n        this.length--;\n\n        if (this.length > 0) {\n            this.data[0] = bottom;\n            this._down(0);\n        }\n\n        return top;\n    }\n\n    peek() {\n        return this.data[0];\n    }\n\n    _up(pos) {\n        const {data, compare} = this;\n        const item = data[pos];\n\n        while (pos > 0) {\n            const parent = (pos - 1) >> 1;\n            const current = data[parent];\n            if (compare(item, current) >= 0) break;\n            data[pos] = current;\n            pos = parent;\n        }\n\n        data[pos] = item;\n    }\n\n    _down(pos) {\n        const {data, compare} = this;\n        const halfLength = this.length >> 1;\n        const item = data[pos];\n\n        while (pos < halfLength) {\n            let left = (pos << 1) + 1;\n            let best = data[left];\n            const right = left + 1;\n\n            if (right < this.length && compare(data[right], best) < 0) {\n                left = right;\n                best = data[right];\n            }\n            if (compare(best, item) >= 0) break;\n\n            data[pos] = best;\n            pos = left;\n        }\n\n        data[pos] = item;\n    }\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n","import { v4 as uuidv4 } from \"uuid\";\nimport inside from \"point-in-polygon\";\nimport earcut from \"earcut\";\nimport QuadTree from \"simple-quadtree\";\nimport TinyQueue from \"tinyqueue\";\n\nimport { Vector, isclose, cross, dot } from \"./math\";\n\nfunction _normalizePoint(point) {\n    if (point instanceof Array) {\n        return new Vector(...point);\n    } else if (point instanceof Vector) {\n        return point;\n    } else if (point.hasOwnProperty(\"x\") && point.hasOwnProperty(\"y\")) {\n        return new Vector(point.x, point.y);\n    }\n}\n\nexport class Edge {\n    constructor(p1, p2) {\n        this._uuid = uuidv4();\n        this.p1 = _normalizePoint(p1);\n        this.p2 = _normalizePoint(p2);\n    }\n\n    length() {\n        return this.p1.sub(this.p2).length();\n    }\n\n    direction() {\n        return this.p1.sub(this.p2);\n    }\n\n    onEdge(point) {\n        point = _normalizePoint(point);\n        const pointVec = this.p1.sub(point);\n\n        if (!this.parallel(pointVec)) return false;\n\n        // test that it's not only collinear, but falls between p1 and p2\n        const direction = this.direction();\n        const len = this.length();\n        const component = dot(direction, pointVec) / (len * len);\n        return component >= 0 && component <= 1;\n    }\n\n    parallel(other) {\n        const otherDirection =\n            other instanceof Vector ? other : other.p1.sub(other.p2);\n        return isclose(cross(this.direction(), otherDirection), 0);\n    }\n\n    collinear(other) {\n        const direction = this.direction();\n        const otherVec1 = this.p1.sub(other.p1);\n        const otherVec2 = this.p1.sub(other.p2);\n        return (\n            isclose(cross(direction, otherVec1), 0) &&\n            isclose(cross(direction, otherVec2), 0)\n        );\n    }\n\n    overlap(other) {\n        if (!this.collinear(other)) {\n            throw new Error(\n                \"Cannot compute overlap of two non-collinear edges.\"\n            );\n        }\n\n        let endpoints = [];\n\n        if (this.onEdge(other.p1)) endpoints.push(other.p1);\n        if (this.onEdge(other.p2)) endpoints.push(other.p2);\n        if (other.onEdge(this.p1)) endpoints.push(this.p1);\n        if (other.onEdge(this.p2)) endpoints.push(this.p2);\n\n        // enpoints can also be the an array with twice the same point,\n        // which is fine as it yields a zero-length edge\n        if (endpoints.length > 2) {\n            endpoints = endpoints.filter(\n                (p, i) => endpoints.findIndex((op) => op.equals(p)) === i\n            );\n        }\n\n        if (!endpoints.length) {\n            return null;\n        } else if (endpoints.length == 1) {\n            endpoints = [endpoints[0], endpoints[0]];\n        }\n\n        return new Edge(...endpoints);\n    }\n\n    distanceToPoint(point) {\n        let squaredLength = dot(this.p2.sub(this.p1), this.p2.sub(this.p1));\n        let r = dot(this.p2.sub(this.p1), point.sub(this.p1));\n        r /= squaredLength;\n\n        if (r < 0) {\n            return point.sub(this.p1).length();\n        } else if (r > 1) {\n            return point.sub(this.p2).length();\n        } else {\n            return Math.sqrt(dot(point.sub(this.p1), point.sub(this.p1)) - r * r * squaredLength);\n        }\n    }\n\n    equals(other) {\n        return (\n            (this.p1.equals(other.p1) && this.p2.equals(other.p2)) ||\n            (this.p1.equals(other.p2) && this.p2.equals(other.p1))\n        );\n    }\n}\n\nexport class Polygon {\n    constructor(points) {\n        this._uuid = uuidv4();\n        this.points = points.map(_normalizePoint);\n        this.bounds = this._computeBounds();\n    }\n\n    _computeBounds() {\n        return this.points.reduce(\n            (a, p) => [\n                Math.min(p.x, a[0]),\n                Math.min(p.y, a[1]),\n                Math.max(p.x, a[2]),\n                Math.max(p.y, a[3]),\n            ],\n            [Infinity, Infinity, -Infinity, -Infinity]\n        );\n    }\n\n    edges() {\n        return this.points.map(\n            (point, i) =>\n                new Edge(\n                    i == 0\n                        ? this.points[this.points.length - 1]\n                        : this.points[i - 1],\n                    point\n                )\n        );\n    }\n\n    centroid() {\n        return this.points\n            .reduce((acc, point) => acc.add(point), new Vector(0, 0))\n            .div(this.points.length);\n    }\n\n    centroidDistance(other) {\n        const centroidVector = this.centroid().sub(other.centroid());\n        return centroidVector.length();\n    }\n\n    contains(point) {\n        point = _normalizePoint(point);\n        const polyPoints = this.points.map(this._toPointArray);\n        return (\n            inside(this._toPointArray(point), polyPoints) ||\n            !!this.onEdge(point)\n        );\n    }\n\n    _toPointArray(point) {\n        return [point.x, point.y];\n    }\n\n    onEdge(point) {\n        point = _normalizePoint(point);\n        for (const edge of this.edges()) {\n            if (edge.onEdge(point)) return edge;\n        }\n\n        return null;\n    }\n\n    touches(otherEdge) {\n        for (const edge of this.edges()) {\n            if (\n                (edge.onEdge(otherEdge.p1) || edge.onEdge(otherEdge.p2)) &&\n                edge.collinear(otherEdge)\n            ) {\n                return edge;\n            }\n        }\n\n        return null;\n    }\n\n    distanceToPoint(point) {\n        let shortest = Infinity;\n        for (const edge of this.edges()) {\n            let dist = edge.distanceToPoint(point);\n            if (dist < shortest) {\n                shortest = dist;\n            }\n        }\n        return shortest;\n    }\n\n    boundsSize() {\n        const [minx, miny, maxx, maxy] = this.bounds;\n        return { x: minx, y: miny, w: maxx - minx, h: maxy - miny };\n    }\n}\n\nexport class NavMesh {\n    constructor(polygons, costFunc = null, heuristicFunc = null, fromTolerance = 0, toTolerance = 0) {\n        this._uuid = uuidv4();\n        this.polygons = this._triangulate(polygons).map(\n            (points) => new Polygon(points)\n        );\n        this.costFunc = costFunc;\n        this.heuristicFunc = heuristicFunc;\n        this.fromTolerance = fromTolerance;\n        this.toTolerance = toTolerance;\n\n        // This will be used to check point collision with\n        // triangles. This should be much smaller that the typical\n        // size of your mesh triangles to avoid checking too many\n        // triangles for collision.\n        this.pointQuerySize = 0.01;\n\n        this._buildQuadtree();\n        this._buildNeighbors();\n    }\n\n    _triangulate(polygons) {\n        const triangles = [];\n        for (const poly of polygons) {\n            const trianglesIndices = earcut(this._flatten(poly));\n            for (let i = 0; i < trianglesIndices.length / 3; i++) {\n                const indices = trianglesIndices.slice(i * 3, i * 3 + 3);\n                triangles.push(indices.map((j) => poly[j]));\n            }\n        }\n        return triangles;\n    }\n\n    _flatten(points) {\n        const flatPoints = [];\n        for (const point of points) {\n            if (point instanceof Array) {\n                flatPoints.push(...point);\n            } else {\n                flatPoints.push(point.x, point.y);\n            }\n        }\n        return flatPoints;\n    }\n\n    _buildQuadtree() {\n        // Use quad tree because the naive approach of iterating\n        // with two nested for loops over the polygons has performance\n        // n*lon(n), which for a 30x30 grid already takes a minute.\n        // This thing, for the same grid, takes 1 second, and scales linearly.\n        this.qt = QuadTree(-Infinity, -Infinity, Infinity, Infinity);\n        for (const poly of this.polygons) {\n            this.qt.put({\n                ...poly.boundsSize(),\n                polygon: poly,\n            });\n        }\n    }\n\n    _buildNeighbors() {\n        this.polygons.forEach((polygon) => (polygon.neighbors = {}));\n\n        for (let i = 0; i < this.polygons.length; i++) {\n            const poly1 = this.polygons[i];\n\n            for (const poly2wrap of this.qt.get(poly1.boundsSize())) {\n                const poly2 = poly2wrap.polygon;\n\n                if (poly1 === poly2) continue;\n                if (poly1.neighbors.hasOwnProperty(poly2._uuid)) continue;\n\n                const portal = this._computePortal(poly1, poly2);\n                if (portal !== null && portal.length() > 0) {\n                    // Ensure that portal points are given in clockwise order, viewed from the centroid of the polygon\n                    let [p1, p2] = this._orderClockwise(poly1.centroid(), portal.p1, portal.p2);\n                    poly1.neighbors[poly2._uuid] = { polygon: poly2, portal: new Edge(p1, p2) };\n                    poly2.neighbors[poly1._uuid] = { polygon: poly1, portal: new Edge(p2, p1) };\n                }\n            }\n        }\n    }\n\n    _computePortal(poly1, poly2) {\n        for (const edge1 of poly1.edges()) {\n            const edge2 = poly2.touches(edge1);\n            if (edge2 !== null) {\n                return edge1.overlap(edge2);\n            }\n        }\n\n        return null;\n    }\n\n    findPath(from, to) {\n        from = _normalizePoint(from);\n        to = _normalizePoint(to);\n\n        const path = this._findPath(from, to);\n        return path && this._funnel(from, to, path);\n    }\n\n    _findPath(from, to) {\n        // This is the A* algorithm\n        const fromPoly = this._findClosestPolygon(from, this.fromTolerance);\n        const toPoly = this._findClosestPolygon(to, this.toTolerance);\n\n        if (fromPoly === null || toPoly === null) return null;\n\n        const frontier = new TinyQueue(\n            [{ cost: 0, polygon: fromPoly }],\n            (a, b) => a.cost - b.cost\n        );\n        const cameFrom = { [fromPoly._uuid]: null };\n        const cost = { [fromPoly._uuid]: 0 };\n\n        while (frontier.length) {\n            const current = frontier.pop().polygon;\n\n            if (current._uuid === toPoly._uuid) {\n                break;\n            }\n\n            for (const { polygon: next } of Object.values(current.neighbors)) {\n                const nextCost =\n                    cost[current._uuid] + this._computeCost(current, next);\n\n                if (\n                    // node not yet visited\n                    !cost.hasOwnProperty(next._uuid) ||\n                    // this path to node has lower cost\n                    nextCost < cost[next._uuid]\n                ) {\n                    frontier.push({\n                        cost: nextCost + this._heuristic(next, toPoly),\n                        polygon: next,\n                    });\n                    cost[next._uuid] = nextCost;\n                    cameFrom[next._uuid] = current;\n                }\n            }\n        }\n\n        return this._reconstructPath(toPoly, cameFrom);\n    }\n\n    _computeDistance(a, b) {\n        return a.centroidDistance(b);\n    }\n\n    _computeCost(a, b) {\n        if (this.costFunc !== null) {\n            const portal = a.neighbors[b._uuid].portal;\n            return this.costFunc(a, b, portal);\n        }\n        return this._computeDistance(a, b);\n    }\n\n    _heuristic(poly, to) {\n        if (poly._uuid == to._uuid) return 0;\n        if (this.heuristicFunc !== null) return this.heuristicFunc(poly, to);\n        return this._computeDistance(poly, to);\n    }\n\n    _findContainingPolygon(point) {\n        const halfQuerySize = this.pointQuerySize / 2;\n        const bounds = {\n            x: point.x - halfQuerySize,\n            y: point.y - halfQuerySize,\n            w: this.pointQuerySize,\n            h: this.pointQuerySize,\n        };\n        for (const poly of this.qt.get(bounds)) {\n            if (poly.polygon.contains(point)) return poly.polygon;\n        }\n\n        return null;\n    }\n\n    _findClosestPolygon(point, searchRadius) {\n        if (searchRadius < this.pointQuerySize / 2) {\n            return this._findContainingPolygon(point);\n        }\n\n        let containingPoly = this._findContainingPolygon(point);\n        if (containingPoly) return containingPoly;\n\n        const bounds = {\n            x: point.x - searchRadius / 2,\n            y: point.y - searchRadius / 2,\n            w: searchRadius,\n            h: searchRadius,\n        };\n        let closestDistance = Infinity;\n        let closestPoly = null;\n        for (const poly of this.qt.get(bounds)) {\n            let distance = poly.polygon.distanceToPoint(point);\n            console.log(distance)\n            if (distance < closestDistance) {\n                closestPoly = poly;\n                closestDistance = distance;\n            }\n        }\n\n        return closestPoly.polygon;\n    }\n\n    _reconstructPath(to, cameFrom) {\n        if (!cameFrom.hasOwnProperty(to._uuid)) {\n            // Disconnected\n            return null;\n        }\n\n        let current = to;\n\n        const path = [];\n        while (current !== null) {\n            path.push(current);\n            current = cameFrom[current._uuid];\n        }\n\n        return path.reverse();\n    }\n\n    /** Funnel algorithm, following https://medium.com/@reza.teshnizi/the-funnel-algorithm-explained-visually-41e374172d2d */\n    _funnel(from, to, path) {\n        if (path.length === 0) {\n            throw new Error(\"Path cannot be empty.\");\n        } else if (path.length === 1) {\n            return [from, to];\n        }\n\n        const tail = [from];\n        const left = [];\n        const right = [];\n\n        // Initialize funnel\n        const initialPortal = path[0].neighbors[path[1]._uuid].portal;\n        left.push(initialPortal.p1);\n        right.push(initialPortal.p2);\n\n        // Iterate over portals\n        for (let i = 1; i < path.length - 1; i++) {\n            const poly = path[i];\n            const nextPoly = path[i + 1];\n            const portal = poly.neighbors[nextPoly._uuid].portal;\n            // The portal end points are in clockwise order, viewed from the inside of the polygon.\n\n            // Extend funnel on the left\n            this._extendFunnel(tail, left, right, true, portal.p1);\n\n            // Extend funnel on the right\n            this._extendFunnel(tail, left, right, false, portal.p2);\n        }\n\n        // Close funnel to endpoint\n        this._extendFunnel(tail, left, right, true, to);\n        this._extendFunnel(tail, left, right, false, to);\n\n        return tail;\n    }\n\n    _extendFunnel(tail, left, right, extendLeft, newPoint){\n        const apex = tail[tail.length - 1];\n        // We pretend to be in the `expandLeft` case here. Otherwise flip.\n        if (!extendLeft) {\n            [left, right] = [right, left];\n        }\n\n        // If `newPoint` is the end point of the left side of the funnel, skip it.\n        const lastLeft = left.length === 0 ? tail[tail.length - 1] : left[left.length - 1];\n        if (newPoint.equals(lastLeft)) {\n            return;\n        }\n\n        // Determine angle of `apex`-`newPoint` relative to `apex`-`left[j]`\n        let j = 0;\n        while (j < left.length\n                && this._isInClockwiseOrder(apex, newPoint, left[j], !extendLeft)) {\n            j++;\n        }\n        // All points in `left` with index `< j` are right of `newPoint` and\n        // all points in `left` with index `>= j` are left of or at the same angle as `newPoint`. \n        left.length = j; // Shrink funnel if `j < left.length`\n        left.push(newPoint);\n        if (j === 0) {\n            // If the funnel shrunk all the way on the left, it might collapse to the right.\n            // Determine how far it needs to collapse\n            let k = 0;\n            while (k < right.length\n                    && !this._isInClockwiseOrder(apex, newPoint, right[k], !extendLeft)) {\n                k++;\n            }\n            // All points in `right` with index `< k` are left of or at the same angle as `newPoint` and\n            // all points in `right` with index `>= k` are right of `newPoint`. \n            tail.push(...right.splice(0, k)); // Collapse funnel if `k > 0`\n        }\n    }\n\n    /** \n     * Are the points `p1` and `p2` in clockwise order, viewed from `origin`?\n     * Checks for counter-clockwise order instead if `flip = true`.\n     * Returns `false` if the angles are equal.\n     */\n    _isInClockwiseOrder(origin, p1, p2, flip = false) {\n        if (flip) {\n            [p1, p2] = [p2, p1];\n        }\n        const vec1 = p1.sub(origin);\n        const vec2 = p2.sub(origin);\n        return cross(vec1, vec2) > 0;\n    }\n\n    /** Returns the points `p1` and `p2` in clockwise order, viewed from `origin`. */\n    _orderClockwise(origin, p1, p2) {\n        if (this._isInClockwiseOrder(origin, p1, p2)) {\n            return [p1, p2];\n        } else {\n            return [p2, p1];\n        }\n    }\n\n}\n","import { Vector, isclose, clip, dot, cross } from \"./math\";\nimport { Edge, Polygon, NavMesh } from \"./navmesh\";\n\nconst Point = Vector;\n\nexport { Point, Vector, isclose, clip, dot, cross, Edge, Polygon, NavMesh };\n"],"sourceRoot":""}