{"version":3,"sources":["webpack://nav2d/webpack/universalModuleDefinition","webpack://nav2d/webpack/bootstrap","webpack://nav2d/external {\"root\":\"uuid\",\"amd\":\"uuid\",\"commonjs2\":\"uuid\",\"commonjs\":\"uuid\"}","webpack://nav2d/external {\"root\":\"point-in-polygon\",\"amd\":\"point-in-polygon\",\"commonjs2\":\"point-in-polygon\",\"commonjs\":\"point-in-polygon\"}","webpack://nav2d/external {\"root\":\"earcut\",\"amd\":\"earcut\",\"commonjs2\":\"earcut\",\"commonjs\":\"earcut\"}","webpack://nav2d/external {\"root\":\"simple-quadtree\",\"amd\":\"simple-quadtree\",\"commonjs2\":\"simple-quadtree\",\"commonjs\":\"simple-quadtree\"}","webpack://nav2d/./src/math.js","webpack://nav2d/./node_modules/tinyqueue/index.js","webpack://nav2d/./src/navmesh.js","webpack://nav2d/./src/nav2d.js"],"names":["root","factory","exports","module","require","define","amd","self","this","__WEBPACK_EXTERNAL_MODULE__0__","__WEBPACK_EXTERNAL_MODULE__1__","__WEBPACK_EXTERNAL_MODULE__2__","__WEBPACK_EXTERNAL_MODULE__3__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Vector","x","y","Error","other","_normOther","Math","sqrt","isclose","acos","clip","dot","length","angle","cross","PI","a","b","eps","v","TinyQueue","data","compare","defaultCompare","_down","item","push","_up","top","bottom","pop","pos","parent","current","halfLength","left","best","right","_normalizePoint","point","Array","Edge","p1","p2","_uuid","uuidv4","sub","pointVec","parallel","direction","len","component","otherDirection","otherVec1","otherVec2","collinear","endpoints","onEdge","filter","findIndex","op","equals","squaredLength","Polygon","points","map","bounds","_computeBounds","reduce","min","max","Infinity","acc","add","div","centroid","polyPoints","_toPointArray","inside","edges","edge","otherEdge","shortest","dist","distanceToPoint","minx","miny","w","h","NavMesh","polygons","costFunc","heuristicFunc","fromTolerance","toTolerance","_triangulate","pointQuerySize","_buildQuadtree","_buildNeighbors","triangles","poly","_flatten","vertices","holes","trianglesIndices","earcut","indices","slice","j","undefined","result","holeIndex","qt","QuadTree","put","boundsSize","polygon","forEach","neighbors","poly1","poly2","portal","_computePortal","_orderLeftRight","edge1","edge2","touches","overlap","from","to","path","_findPath","_funnel","fromPoly","_findClosestPolygon","toPoly","frontier","cost","cameFrom","values","next","nextCost","_computeCost","_heuristic","_reconstructPath","centroidDistance","_computeDistance","halfQuerySize","contains","searchRadius","_findContainingPolygon","containingPoly","closestDistance","closestPoly","distance","console","log","reverse","tail","initialPortal","nextPoly","_extendFunnel","leftPoint","rightPoint","_extendFunnelSide","extendLeft","newPoint","apex","lastLeft","_findFirstLeftOfPoint","k","splice","origin","arr","acceptColinear","flip","_isInLeftRightOrder","vec1","vec2","Point"],"mappings":"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","file":"nav2d.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"uuid\"), require(\"point-in-polygon\"), require(\"earcut\"), require(\"simple-quadtree\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"uuid\", \"point-in-polygon\", \"earcut\", \"simple-quadtree\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"nav2d\"] = factory(require(\"uuid\"), require(\"point-in-polygon\"), require(\"earcut\"), require(\"simple-quadtree\"));\n\telse\n\t\troot[\"nav2d\"] = factory(root[\"uuid\"], root[\"point-in-polygon\"], root[\"earcut\"], root[\"simple-quadtree\"]);\n})((typeof self !== 'undefined' ? self : this), function(__WEBPACK_EXTERNAL_MODULE__0__, __WEBPACK_EXTERNAL_MODULE__1__, __WEBPACK_EXTERNAL_MODULE__2__, __WEBPACK_EXTERNAL_MODULE__3__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","module.exports = __WEBPACK_EXTERNAL_MODULE__1__;","module.exports = __WEBPACK_EXTERNAL_MODULE__2__;","module.exports = __WEBPACK_EXTERNAL_MODULE__3__;","export const EPS = 1e-8;\n\nexport class Vector {\n    constructor(x, y) {\n        if (typeof x !== \"number\" || typeof y !== \"number\") {\n            throw new Error(\"Vector components must be numbers.\");\n        }\n\n        this.x = x;\n        this.y = y;\n    }\n\n    _normOther(other) {\n        if (typeof other == \"number\") {\n            return new Vector(other, other);\n        }\n        return other;\n    }\n\n    add(other) {\n        other = this._normOther(other);\n        return new Vector(this.x + other.x, this.y + other.y);\n    }\n\n    sub(other) {\n        other = this._normOther(other);\n        return new Vector(this.x - other.x, this.y - other.y);\n    }\n\n    mul(other) {\n        other = this._normOther(other);\n        return new Vector(this.x * other.x, this.y * other.y);\n    }\n\n    div(other) {\n        other = this._normOther(other);\n        return new Vector(this.x / other.x, this.y / other.y);\n    }\n\n    length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n\n    equals(other) {\n        return isclose(this.x, other.x) && isclose(this.y, other.y);\n    }\n\n    angle(other) {\n        return Math.acos(\n            clip(-1, 1, dot(this, other) / (this.length() * other.length()))\n        );\n    }\n\n    counterclockwiseAngle(other) {\n        const angle = this.angle(other);\n        return cross(this, other) >= 0 ? angle : 2 * Math.PI - angle;\n    }\n\n    toString() {\n        return `{ x: ${this.x}, y: ${this.y} }`;\n    }\n}\n\nexport function dot(a, b) {\n    return a.x * b.x + a.y * b.y;\n}\n\nexport function cross(a, b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nexport function isclose(a, b, eps = EPS) {\n    return a > b - eps && a < b + eps;\n}\n\nexport function clip(a, b, v) {\n    if (v < a) return a;\n    if (v > b) return b;\n    return v;\n}\n","\nexport default class TinyQueue {\n    constructor(data = [], compare = defaultCompare) {\n        this.data = data;\n        this.length = this.data.length;\n        this.compare = compare;\n\n        if (this.length > 0) {\n            for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);\n        }\n    }\n\n    push(item) {\n        this.data.push(item);\n        this.length++;\n        this._up(this.length - 1);\n    }\n\n    pop() {\n        if (this.length === 0) return undefined;\n\n        const top = this.data[0];\n        const bottom = this.data.pop();\n        this.length--;\n\n        if (this.length > 0) {\n            this.data[0] = bottom;\n            this._down(0);\n        }\n\n        return top;\n    }\n\n    peek() {\n        return this.data[0];\n    }\n\n    _up(pos) {\n        const {data, compare} = this;\n        const item = data[pos];\n\n        while (pos > 0) {\n            const parent = (pos - 1) >> 1;\n            const current = data[parent];\n            if (compare(item, current) >= 0) break;\n            data[pos] = current;\n            pos = parent;\n        }\n\n        data[pos] = item;\n    }\n\n    _down(pos) {\n        const {data, compare} = this;\n        const halfLength = this.length >> 1;\n        const item = data[pos];\n\n        while (pos < halfLength) {\n            let left = (pos << 1) + 1;\n            let best = data[left];\n            const right = left + 1;\n\n            if (right < this.length && compare(data[right], best) < 0) {\n                left = right;\n                best = data[right];\n            }\n            if (compare(best, item) >= 0) break;\n\n            data[pos] = best;\n            pos = left;\n        }\n\n        data[pos] = item;\n    }\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n","import { v4 as uuidv4 } from \"uuid\";\nimport inside from \"point-in-polygon\";\nimport earcut from \"earcut\";\nimport QuadTree from \"simple-quadtree\";\nimport TinyQueue from \"tinyqueue\";\n\nimport { Vector, isclose, cross, dot } from \"./math\";\n\nfunction _normalizePoint(point) {\n    if (point instanceof Array) {\n        return new Vector(...point);\n    } else if (point instanceof Vector) {\n        return point;\n    } else if (point.hasOwnProperty(\"x\") && point.hasOwnProperty(\"y\")) {\n        return new Vector(point.x, point.y);\n    }\n}\n\nexport class Edge {\n    constructor(p1, p2) {\n        this._uuid = uuidv4();\n        this.p1 = _normalizePoint(p1);\n        this.p2 = _normalizePoint(p2);\n    }\n\n    length() {\n        return this.p1.sub(this.p2).length();\n    }\n\n    direction() {\n        return this.p1.sub(this.p2);\n    }\n\n    onEdge(point) {\n        point = _normalizePoint(point);\n        const pointVec = this.p1.sub(point);\n\n        if (!this.parallel(pointVec)) return false;\n\n        // test that it's not only collinear, but falls between p1 and p2\n        const direction = this.direction();\n        const len = this.length();\n        const component = dot(direction, pointVec) / (len * len);\n        return component >= 0 && component <= 1;\n    }\n\n    parallel(other) {\n        const otherDirection =\n            other instanceof Vector ? other : other.p1.sub(other.p2);\n        return isclose(cross(this.direction(), otherDirection), 0);\n    }\n\n    collinear(other) {\n        const direction = this.direction();\n        const otherVec1 = this.p1.sub(other.p1);\n        const otherVec2 = this.p1.sub(other.p2);\n        return (\n            isclose(cross(direction, otherVec1), 0) &&\n            isclose(cross(direction, otherVec2), 0)\n        );\n    }\n\n    overlap(other) {\n        if (!this.collinear(other)) {\n            throw new Error(\n                \"Cannot compute overlap of two non-collinear edges.\"\n            );\n        }\n\n        let endpoints = [];\n\n        if (this.onEdge(other.p1)) endpoints.push(other.p1);\n        if (this.onEdge(other.p2)) endpoints.push(other.p2);\n        if (other.onEdge(this.p1)) endpoints.push(this.p1);\n        if (other.onEdge(this.p2)) endpoints.push(this.p2);\n\n        // enpoints can also be the an array with twice the same point,\n        // which is fine as it yields a zero-length edge\n        if (endpoints.length > 2) {\n            endpoints = endpoints.filter(\n                (p, i) => endpoints.findIndex((op) => op.equals(p)) === i\n            );\n        }\n\n        if (!endpoints.length) {\n            return null;\n        } else if (endpoints.length == 1) {\n            endpoints = [endpoints[0], endpoints[0]];\n        }\n\n        return new Edge(...endpoints);\n    }\n\n    distanceToPoint(point) {\n        let squaredLength = dot(this.p2.sub(this.p1), this.p2.sub(this.p1));\n        let r = dot(this.p2.sub(this.p1), point.sub(this.p1));\n        r /= squaredLength;\n\n        if (r < 0) {\n            return point.sub(this.p1).length();\n        } else if (r > 1) {\n            return point.sub(this.p2).length();\n        } else {\n            return Math.sqrt(dot(point.sub(this.p1), point.sub(this.p1)) - r * r * squaredLength);\n        }\n    }\n\n    equals(other) {\n        return (\n            (this.p1.equals(other.p1) && this.p2.equals(other.p2)) ||\n            (this.p1.equals(other.p2) && this.p2.equals(other.p1))\n        );\n    }\n}\n\nexport class Polygon {\n    constructor(points) {\n        this._uuid = uuidv4();\n        this.points = points.map(_normalizePoint);\n        this.bounds = this._computeBounds();\n    }\n\n    _computeBounds() {\n        return this.points.reduce(\n            (a, p) => [\n                Math.min(p.x, a[0]),\n                Math.min(p.y, a[1]),\n                Math.max(p.x, a[2]),\n                Math.max(p.y, a[3]),\n            ],\n            [Infinity, Infinity, -Infinity, -Infinity]\n        );\n    }\n\n    edges() {\n        return this.points.map(\n            (point, i) =>\n                new Edge(\n                    i == 0\n                        ? this.points[this.points.length - 1]\n                        : this.points[i - 1],\n                    point\n                )\n        );\n    }\n\n    centroid() {\n        return this.points\n            .reduce((acc, point) => acc.add(point), new Vector(0, 0))\n            .div(this.points.length);\n    }\n\n    centroidDistance(other) {\n        const centroidVector = this.centroid().sub(other.centroid());\n        return centroidVector.length();\n    }\n\n    contains(point) {\n        point = _normalizePoint(point);\n        const polyPoints = this.points.map(this._toPointArray);\n        return (\n            inside(this._toPointArray(point), polyPoints) ||\n            !!this.onEdge(point)\n        );\n    }\n\n    _toPointArray(point) {\n        return [point.x, point.y];\n    }\n\n    onEdge(point) {\n        point = _normalizePoint(point);\n        for (const edge of this.edges()) {\n            if (edge.onEdge(point)) return edge;\n        }\n\n        return null;\n    }\n\n    touches(otherEdge) {\n        for (const edge of this.edges()) {\n            if (\n                (edge.onEdge(otherEdge.p1) || edge.onEdge(otherEdge.p2)) &&\n                edge.collinear(otherEdge)\n            ) {\n                return edge;\n            }\n        }\n\n        return null;\n    }\n\n    distanceToPoint(point) {\n        let shortest = Infinity;\n        for (const edge of this.edges()) {\n            let dist = edge.distanceToPoint(point);\n            if (dist < shortest) {\n                shortest = dist;\n            }\n        }\n        return shortest;\n    }\n\n    boundsSize() {\n        const [minx, miny, maxx, maxy] = this.bounds;\n        return { x: minx, y: miny, w: maxx - minx, h: maxy - miny };\n    }\n}\n\nexport class NavMesh {\n    constructor(polygons, costFunc = null, heuristicFunc = null, fromTolerance = 0, toTolerance = 0) {\n        this._uuid = uuidv4();\n        this.polygons = this._triangulate(polygons).map(\n            (points) => new Polygon(points)\n        );\n        this.costFunc = costFunc;\n        this.heuristicFunc = heuristicFunc;\n        this.fromTolerance = fromTolerance;\n        this.toTolerance = toTolerance;\n\n        // This will be used to check point collision with\n        // triangles. This should be much smaller that the typical\n        // size of your mesh triangles to avoid checking too many\n        // triangles for collision.\n        this.pointQuerySize = 0.01;\n\n        this._buildQuadtree();\n        this._buildNeighbors();\n    }\n\n    _triangulate(polygons) {\n        const triangles = [];\n        for (const poly of polygons) {\n            const { vertices, holes } = this._flatten(poly);\n            const trianglesIndices = earcut(vertices, holes);\n            for (let i = 0; i < trianglesIndices.length / 3; i++) {\n                const indices = trianglesIndices.slice(i * 3, i * 3 + 3);\n                triangles.push(\n                    indices.map(  \n                        (j) => new Vector(vertices[2 * j], vertices[2 * j + 1])\n                    )\n                );\n            }\n        }\n        return triangles;\n    }\n\n    _flatten(data) {\n        if (data[0].x !== undefined || typeof data[0][0] === \"number\") {\n            // Polygon without holes\n            data = [data];\n        }\n\n        let result = { vertices: [], holes: [] };\n        let holeIndex = 0;\n\n        for (let i = 0; i < data.length; i++) {\n            for (let point of data[i]) {\n                if (point instanceof Array) {\n                    result.vertices.push(...point);\n                } else {\n                    result.vertices.push(point.x, point.y);\n                }\n            }\n            if (i > 0) {\n                holeIndex += data[i - 1].length;\n                result.holes.push(holeIndex);\n            }\n        }\n        return result;\n    }\n\n    _buildQuadtree() {\n        // Use quad tree because the naive approach of iterating\n        // with two nested for loops over the polygons has performance\n        // n*lon(n), which for a 30x30 grid already takes a minute.\n        // This thing, for the same grid, takes 1 second, and scales linearly.\n        this.qt = QuadTree(-Infinity, -Infinity, Infinity, Infinity);\n        for (const poly of this.polygons) {\n            this.qt.put({\n                ...poly.boundsSize(),\n                polygon: poly,\n            });\n        }\n    }\n\n    _buildNeighbors() {\n        this.polygons.forEach((polygon) => (polygon.neighbors = {}));\n\n        for (let i = 0; i < this.polygons.length; i++) {\n            const poly1 = this.polygons[i];\n\n            for (const poly2wrap of this.qt.get(poly1.boundsSize())) {\n                const poly2 = poly2wrap.polygon;\n\n                if (poly1 === poly2) continue;\n                if (poly1.neighbors.hasOwnProperty(poly2._uuid)) continue;\n\n                const portal = this._computePortal(poly1, poly2);\n                if (portal !== null && portal.length() > 0) {\n                    // Ensure that portal points are given in left-to-right order, viewed from the centroid of the polygon\n                    let [p1, p2] = this._orderLeftRight(\n                        poly1.centroid(),\n                        portal.p1,\n                        portal.p2\n                    );\n                    poly1.neighbors[poly2._uuid] = {\n                        polygon: poly2,\n                        portal: new Edge(p1, p2),\n                    };\n                    poly2.neighbors[poly1._uuid] = {\n                        polygon: poly1,\n                        portal: new Edge(p2, p1),\n                    };\n                }\n            }\n        }\n    }\n\n    _computePortal(poly1, poly2) {\n        for (const edge1 of poly1.edges()) {\n            const edge2 = poly2.touches(edge1);\n            if (edge2 !== null) {\n                return edge1.overlap(edge2);\n            }\n        }\n\n        return null;\n    }\n\n    findPath(from, to) {\n        from = _normalizePoint(from);\n        to = _normalizePoint(to);\n\n        const path = this._findPath(from, to);\n        return path && this._funnel(from, to, path);\n    }\n\n    _findPath(from, to) {\n        // This is the A* algorithm\n        const fromPoly = this._findClosestPolygon(from, this.fromTolerance);\n        const toPoly = this._findClosestPolygon(to, this.toTolerance);\n\n        if (fromPoly === null || toPoly === null) return null;\n\n        const frontier = new TinyQueue(\n            [{ cost: 0, polygon: fromPoly }],\n            (a, b) => a.cost - b.cost\n        );\n        const cameFrom = { [fromPoly._uuid]: null };\n        const cost = { [fromPoly._uuid]: 0 };\n\n        while (frontier.length) {\n            const current = frontier.pop().polygon;\n\n            if (current._uuid === toPoly._uuid) {\n                break;\n            }\n\n            for (const { polygon: next } of Object.values(current.neighbors)) {\n                const nextCost =\n                    cost[current._uuid] + this._computeCost(current, next);\n\n                if (\n                    // node not yet visited\n                    !cost.hasOwnProperty(next._uuid) ||\n                    // this path to node has lower cost\n                    nextCost < cost[next._uuid]\n                ) {\n                    frontier.push({\n                        cost: nextCost + this._heuristic(next, toPoly),\n                        polygon: next,\n                    });\n                    cost[next._uuid] = nextCost;\n                    cameFrom[next._uuid] = current;\n                }\n            }\n        }\n\n        return this._reconstructPath(toPoly, cameFrom);\n    }\n\n    _computeDistance(a, b) {\n        return a.centroidDistance(b);\n    }\n\n    _computeCost(a, b) {\n        if (this.costFunc !== null) {\n            const portal = a.neighbors[b._uuid].portal;\n            return this.costFunc(a, b, portal);\n        }\n        return this._computeDistance(a, b);\n    }\n\n    _heuristic(poly, to) {\n        if (poly._uuid == to._uuid) return 0;\n        if (this.heuristicFunc !== null) return this.heuristicFunc(poly, to);\n        return this._computeDistance(poly, to);\n    }\n\n    _findContainingPolygon(point) {\n        const halfQuerySize = this.pointQuerySize / 2;\n        const bounds = {\n            x: point.x - halfQuerySize,\n            y: point.y - halfQuerySize,\n            w: this.pointQuerySize,\n            h: this.pointQuerySize,\n        };\n        for (const poly of this.qt.get(bounds)) {\n            if (poly.polygon.contains(point)) return poly.polygon;\n        }\n\n        return null;\n    }\n\n    _findClosestPolygon(point, searchRadius) {\n        if (searchRadius < this.pointQuerySize / 2) {\n            return this._findContainingPolygon(point);\n        }\n\n        let containingPoly = this._findContainingPolygon(point);\n        if (containingPoly) return containingPoly;\n\n        const bounds = {\n            x: point.x - searchRadius / 2,\n            y: point.y - searchRadius / 2,\n            w: searchRadius,\n            h: searchRadius,\n        };\n        let closestDistance = Infinity;\n        let closestPoly = null;\n        for (const poly of this.qt.get(bounds)) {\n            let distance = poly.polygon.distanceToPoint(point);\n            console.log(distance)\n            if (distance < closestDistance) {\n                closestPoly = poly;\n                closestDistance = distance;\n            }\n        }\n\n        return closestPoly.polygon;\n    }\n\n    _reconstructPath(to, cameFrom) {\n        if (!cameFrom.hasOwnProperty(to._uuid)) {\n            // Disconnected\n            return null;\n        }\n\n        let current = to;\n\n        const path = [];\n        while (current !== null) {\n            path.push(current);\n            current = cameFrom[current._uuid];\n        }\n\n        return path.reverse();\n    }\n\n    /** Funnel algorithm, following https://medium.com/@reza.teshnizi/the-funnel-algorithm-explained-visually-41e374172d2d */\n    _funnel(from, to, path) {\n        if (path.length === 0) {\n            throw new Error(\"Path cannot be empty.\");\n        } else if (path.length === 1) {\n            return [from, to];\n        }\n\n        const tail = [from];\n        const left = [];\n        const right = [];\n\n        // Initialize funnel\n        const initialPortal = path[0].neighbors[path[1]._uuid].portal;\n        left.push(initialPortal.p1);\n        right.push(initialPortal.p2);\n\n        // Iterate over portals\n        for (let i = 1; i < path.length - 1; i++) {\n            const poly = path[i];\n            const nextPoly = path[i + 1];\n            const portal = poly.neighbors[nextPoly._uuid].portal;\n            // The portal end points are in left-to-right order, viewed from the inside of the polygon.\n            this._extendFunnel(tail, left, right, portal.p1, portal.p2);\n        }\n\n        // Close funnel to endpoint\n        this._extendFunnel(tail, left, right, to, to);\n\n        return tail;\n    }\n\n    _extendFunnel(tail, left, right, leftPoint, rightPoint) {\n        // Extend funnel on the left\n        this._extendFunnelSide(tail, left, right, true, leftPoint);\n        // Extend funnel on the right\n        this._extendFunnelSide(tail, left, right, false, rightPoint);\n    }\n\n    _extendFunnelSide(tail, left, right, extendLeft, newPoint) {\n        const apex = tail[tail.length - 1];\n        // We pretend to be in the `expandLeft` case here. Otherwise flip.\n        if (!extendLeft) {\n            [left, right] = [right, left];\n        }\n\n        // If `newPoint` is the end point of the left side of the funnel, skip it.\n        const lastLeft =\n            left.length === 0 ? tail[tail.length - 1] : left[left.length - 1];\n        if (newPoint.equals(lastLeft)) {\n            return;\n        }\n\n        // Determine how far to shrink the funnel\n        let j = this._findFirstLeftOfPoint(\n            apex,\n            left,\n            newPoint,\n            true,\n            !extendLeft\n        );\n        // All points in `left` with index `< j` are right of `newPoint` and\n        // all points in `left` with index `>= j` are left of or at the same angle as `newPoint`.\n        left.length = j; // Shrink funnel if `j < left.length`\n        left.push(newPoint);\n        if (j === 0) {\n            // If the funnel shrunk all the way on the left, it might collapse to the right.\n            // Determine how far it needs to collapse\n            let k = this._findFirstLeftOfPoint(\n                apex,\n                right,\n                newPoint,\n                false,\n                extendLeft\n            );\n            // All points in `right` with index `< k` are left of or at the same angle as `newPoint` and\n            // all points in `right` with index `>= k` are right of `newPoint`.\n            tail.push(...right.splice(0, k)); // Collapse funnel if `k > 0`\n        }\n    }\n\n    /**\n     * Given an array `arr` of points, find the index of the first one that is\n     * on the left side of a given point `p`, viewed from `origin`. If no such\n     * point exists, the length of the list is returned.\n     *\n     * If `flip` is true, find the first that is on the right side instead.\n     *\n     * If `acceptColinear` is true, the returned point may also be colinear.\n     */\n    _findFirstLeftOfPoint(origin, arr, p, acceptColinear, flip) {\n        let i;\n        for (i = 0; i < arr.length; i++) {\n            const found = flip\n                ? this._isInLeftRightOrder(origin, p, arr[i], acceptColinear)\n                : this._isInLeftRightOrder(origin, arr[i], p, acceptColinear);\n            if (found) return i;\n        }\n        return i;\n    }\n\n    /**\n     * Are the points `p1` and `p2` in left-to-right order, viewed from `origin`?\n     * If points are colinear, the value of `acceptColinear` is returned.\n     */\n    _isInLeftRightOrder(origin, p1, p2, acceptColinear = false) {\n        const vec1 = p1.sub(origin);\n        const vec2 = p2.sub(origin);\n        const c = cross(vec1, vec2);\n        return acceptColinear ? c <= 0 : c < 0;\n    }\n\n    /** Returns the points `p1` and `p2` in left-to-right order, viewed from `origin`. */\n    _orderLeftRight(origin, p1, p2) {\n        if (this._isInLeftRightOrder(origin, p1, p2)) {\n            return [p1, p2];\n        } else {\n            return [p2, p1];\n        }\n    }\n}\n","import { Vector, isclose, clip, dot, cross } from \"./math\";\nimport { Edge, Polygon, NavMesh } from \"./navmesh\";\n\nconst Point = Vector;\n\nexport { Point, Vector, isclose, clip, dot, cross, Edge, Polygon, NavMesh };\n"],"sourceRoot":""}