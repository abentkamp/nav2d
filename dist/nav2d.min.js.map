{"version":3,"sources":["webpack://nav2d/webpack/universalModuleDefinition","webpack://nav2d/webpack/bootstrap","webpack://nav2d/external {\"root\":\"uuid\",\"amd\":\"uuid\",\"commonjs2\":\"uuid\",\"commonjs\":\"uuid\"}","webpack://nav2d/external {\"root\":\"point-in-polygon\",\"amd\":\"point-in-polygon\",\"commonjs2\":\"point-in-polygon\",\"commonjs\":\"point-in-polygon\"}","webpack://nav2d/external {\"root\":\"earcut\",\"amd\":\"earcut\",\"commonjs2\":\"earcut\",\"commonjs\":\"earcut\"}","webpack://nav2d/external {\"root\":\"simple-quadtree\",\"amd\":\"simple-quadtree\",\"commonjs2\":\"simple-quadtree\",\"commonjs\":\"simple-quadtree\"}","webpack://nav2d/./src/math.js","webpack://nav2d/./node_modules/tinyqueue/index.js","webpack://nav2d/./src/navmesh.js","webpack://nav2d/./src/nav2d.js"],"names":["root","factory","exports","module","require","define","amd","self","this","__WEBPACK_EXTERNAL_MODULE__0__","__WEBPACK_EXTERNAL_MODULE__1__","__WEBPACK_EXTERNAL_MODULE__2__","__WEBPACK_EXTERNAL_MODULE__3__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Vector","x","y","Error","other","_normOther","Math","sqrt","isclose","acos","clip","dot","length","angle","cross","PI","a","b","eps","v","TinyQueue","data","compare","defaultCompare","_down","item","push","_up","top","bottom","pop","pos","parent","current","halfLength","left","best","right","_normalizePoint","point","Array","Edge","p1","p2","_uuid","uuidv4","sub","pointVec","parallel","direction","len","component","otherDirection","otherVec1","otherVec2","collinear","endpoints","onEdge","filter","findIndex","op","equals","squaredLength","Polygon","points","map","bounds","_computeBounds","reduce","min","max","Infinity","acc","add","div","centroid","polyPoints","_toPointArray","inside","edges","edge","otherEdge","shortest","dist","distanceToPoint","minx","miny","w","h","NavMesh","polygons","costFunc","heuristicFunc","fromTolerance","toTolerance","_triangulate","pointQuerySize","_buildQuadtree","_buildNeighbors","triangles","poly","trianglesIndices","earcut","_flatten","indices","slice","j","flatPoints","qt","QuadTree","put","boundsSize","polygon","forEach","neighbors","poly1","poly2","portal","_computePortal","_orderClockwise","edge1","edge2","touches","overlap","from","to","path","_findPath","_funnel","fromPoly","_findClosestPolygon","toPoly","frontier","cost","cameFrom","values","next","nextCost","_computeCost","_heuristic","_reconstructPath","centroidDistance","_computeDistance","halfQuerySize","contains","searchRadius","_findContainingPolygon","containingPoly","closestDistance","closestPoly","distance","console","log","reverse","tail","initialPortal","nextPoly","_extendFunnel","extendLeft","newPoint","apex","lastLeft","_isInClockwiseOrder","k","splice","origin","flip","vec1","vec2","Point"],"mappings":"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","file":"nav2d.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"uuid\"), require(\"point-in-polygon\"), require(\"earcut\"), require(\"simple-quadtree\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"uuid\", \"point-in-polygon\", \"earcut\", \"simple-quadtree\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"nav2d\"] = factory(require(\"uuid\"), require(\"point-in-polygon\"), require(\"earcut\"), require(\"simple-quadtree\"));\n\telse\n\t\troot[\"nav2d\"] = factory(root[\"uuid\"], root[\"point-in-polygon\"], root[\"earcut\"], root[\"simple-quadtree\"]);\n})((typeof self !== 'undefined' ? self : this), function(__WEBPACK_EXTERNAL_MODULE__0__, __WEBPACK_EXTERNAL_MODULE__1__, __WEBPACK_EXTERNAL_MODULE__2__, __WEBPACK_EXTERNAL_MODULE__3__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","module.exports = __WEBPACK_EXTERNAL_MODULE__1__;","module.exports = __WEBPACK_EXTERNAL_MODULE__2__;","module.exports = __WEBPACK_EXTERNAL_MODULE__3__;","export const EPS = 1e-8;\n\nexport class Vector {\n    constructor(x, y) {\n        if (typeof x !== \"number\" || typeof y !== \"number\") {\n            throw new Error(\"Vector components must be numbers.\");\n        }\n\n        this.x = x;\n        this.y = y;\n    }\n\n    _normOther(other) {\n        if (typeof other == \"number\") {\n            return new Vector(other, other);\n        }\n        return other;\n    }\n\n    add(other) {\n        other = this._normOther(other);\n        return new Vector(this.x + other.x, this.y + other.y);\n    }\n\n    sub(other) {\n        other = this._normOther(other);\n        return new Vector(this.x - other.x, this.y - other.y);\n    }\n\n    mul(other) {\n        other = this._normOther(other);\n        return new Vector(this.x * other.x, this.y * other.y);\n    }\n\n    div(other) {\n        other = this._normOther(other);\n        return new Vector(this.x / other.x, this.y / other.y);\n    }\n\n    length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n\n    equals(other) {\n        return isclose(this.x, other.x) && isclose(this.y, other.y);\n    }\n\n    angle(other) {\n        return Math.acos(\n            clip(-1, 1, dot(this, other) / (this.length() * other.length()))\n        );\n    }\n\n    counterclockwiseAngle(other) {\n        const angle = this.angle(other);\n        return cross(this, other) >= 0 ? angle : 2 * Math.PI - angle;\n    }\n\n    toString() {\n        return `{ x: ${this.x}, y: ${this.y} }`;\n    }\n}\n\nexport function dot(a, b) {\n    return a.x * b.x + a.y * b.y;\n}\n\nexport function cross(a, b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nexport function isclose(a, b, eps = EPS) {\n    return a > b - eps && a < b + eps;\n}\n\nexport function clip(a, b, v) {\n    if (v < a) return a;\n    if (v > b) return b;\n    return v;\n}\n","\nexport default class TinyQueue {\n    constructor(data = [], compare = defaultCompare) {\n        this.data = data;\n        this.length = this.data.length;\n        this.compare = compare;\n\n        if (this.length > 0) {\n            for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);\n        }\n    }\n\n    push(item) {\n        this.data.push(item);\n        this.length++;\n        this._up(this.length - 1);\n    }\n\n    pop() {\n        if (this.length === 0) return undefined;\n\n        const top = this.data[0];\n        const bottom = this.data.pop();\n        this.length--;\n\n        if (this.length > 0) {\n            this.data[0] = bottom;\n            this._down(0);\n        }\n\n        return top;\n    }\n\n    peek() {\n        return this.data[0];\n    }\n\n    _up(pos) {\n        const {data, compare} = this;\n        const item = data[pos];\n\n        while (pos > 0) {\n            const parent = (pos - 1) >> 1;\n            const current = data[parent];\n            if (compare(item, current) >= 0) break;\n            data[pos] = current;\n            pos = parent;\n        }\n\n        data[pos] = item;\n    }\n\n    _down(pos) {\n        const {data, compare} = this;\n        const halfLength = this.length >> 1;\n        const item = data[pos];\n\n        while (pos < halfLength) {\n            let left = (pos << 1) + 1;\n            let best = data[left];\n            const right = left + 1;\n\n            if (right < this.length && compare(data[right], best) < 0) {\n                left = right;\n                best = data[right];\n            }\n            if (compare(best, item) >= 0) break;\n\n            data[pos] = best;\n            pos = left;\n        }\n\n        data[pos] = item;\n    }\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n","import { v4 as uuidv4 } from \"uuid\";\nimport inside from \"point-in-polygon\";\nimport earcut from \"earcut\";\nimport QuadTree from \"simple-quadtree\";\nimport TinyQueue from \"tinyqueue\";\n\nimport { Vector, isclose, cross, dot } from \"./math\";\n\nfunction _normalizePoint(point) {\n    if (point instanceof Array) {\n        return new Vector(...point);\n    } else if (point instanceof Vector) {\n        return point;\n    } else if (point.hasOwnProperty(\"x\") && point.hasOwnProperty(\"y\")) {\n        return new Vector(point.x, point.y);\n    }\n}\n\nexport class Edge {\n    constructor(p1, p2) {\n        this._uuid = uuidv4();\n        this.p1 = _normalizePoint(p1);\n        this.p2 = _normalizePoint(p2);\n    }\n\n    length() {\n        return this.p1.sub(this.p2).length();\n    }\n\n    direction() {\n        return this.p1.sub(this.p2);\n    }\n\n    onEdge(point) {\n        point = _normalizePoint(point);\n        const pointVec = this.p1.sub(point);\n\n        if (!this.parallel(pointVec)) return false;\n\n        // test that it's not only collinear, but falls between p1 and p2\n        const direction = this.direction();\n        const len = this.length();\n        const component = dot(direction, pointVec) / (len * len);\n        return component >= 0 && component <= 1;\n    }\n\n    parallel(other) {\n        const otherDirection =\n            other instanceof Vector ? other : other.p1.sub(other.p2);\n        return isclose(cross(this.direction(), otherDirection), 0);\n    }\n\n    collinear(other) {\n        const direction = this.direction();\n        const otherVec1 = this.p1.sub(other.p1);\n        const otherVec2 = this.p1.sub(other.p2);\n        return (\n            isclose(cross(direction, otherVec1), 0) &&\n            isclose(cross(direction, otherVec2), 0)\n        );\n    }\n\n    overlap(other) {\n        if (!this.collinear(other)) {\n            throw new Error(\n                \"Cannot compute overlap of two non-collinear edges.\"\n            );\n        }\n\n        let endpoints = [];\n\n        if (this.onEdge(other.p1)) endpoints.push(other.p1);\n        if (this.onEdge(other.p2)) endpoints.push(other.p2);\n        if (other.onEdge(this.p1)) endpoints.push(this.p1);\n        if (other.onEdge(this.p2)) endpoints.push(this.p2);\n\n        // enpoints can also be the an array with twice the same point,\n        // which is fine as it yields a zero-length edge\n        if (endpoints.length > 2) {\n            endpoints = endpoints.filter(\n                (p, i) => endpoints.findIndex((op) => op.equals(p)) === i\n            );\n        }\n\n        if (!endpoints.length) {\n            return null;\n        } else if (endpoints.length == 1) {\n            endpoints = [endpoints[0], endpoints[0]];\n        }\n\n        return new Edge(...endpoints);\n    }\n\n    distanceToPoint(point) {\n        let squaredLength = dot(this.p2.sub(this.p1), this.p2.sub(this.p1));\n        let r = dot(this.p2.sub(this.p1), point.sub(this.p1));\n        r /= squaredLength;\n\n        if (r < 0) {\n            return point.sub(this.p1).length();\n        } else if (r > 1) {\n            return point.sub(this.p2).length();\n        } else {\n            return Math.sqrt(dot(point.sub(this.p1), point.sub(this.p1)) - r * r * squaredLength);\n        }\n    }\n\n    equals(other) {\n        return (\n            (this.p1.equals(other.p1) && this.p2.equals(other.p2)) ||\n            (this.p1.equals(other.p2) && this.p2.equals(other.p1))\n        );\n    }\n}\n\nexport class Polygon {\n    constructor(points) {\n        this._uuid = uuidv4();\n        this.points = points.map(_normalizePoint);\n        this.bounds = this._computeBounds();\n    }\n\n    _computeBounds() {\n        return this.points.reduce(\n            (a, p) => [\n                Math.min(p.x, a[0]),\n                Math.min(p.y, a[1]),\n                Math.max(p.x, a[2]),\n                Math.max(p.y, a[3]),\n            ],\n            [Infinity, Infinity, -Infinity, -Infinity]\n        );\n    }\n\n    edges() {\n        return this.points.map(\n            (point, i) =>\n                new Edge(\n                    i == 0\n                        ? this.points[this.points.length - 1]\n                        : this.points[i - 1],\n                    point\n                )\n        );\n    }\n\n    centroid() {\n        return this.points\n            .reduce((acc, point) => acc.add(point), new Vector(0, 0))\n            .div(this.points.length);\n    }\n\n    centroidDistance(other) {\n        const centroidVector = this.centroid().sub(other.centroid());\n        return centroidVector.length();\n    }\n\n    contains(point) {\n        point = _normalizePoint(point);\n        const polyPoints = this.points.map(this._toPointArray);\n        return (\n            inside(this._toPointArray(point), polyPoints) ||\n            !!this.onEdge(point)\n        );\n    }\n\n    _toPointArray(point) {\n        return [point.x, point.y];\n    }\n\n    onEdge(point) {\n        point = _normalizePoint(point);\n        for (const edge of this.edges()) {\n            if (edge.onEdge(point)) return edge;\n        }\n\n        return null;\n    }\n\n    touches(otherEdge) {\n        for (const edge of this.edges()) {\n            if (\n                (edge.onEdge(otherEdge.p1) || edge.onEdge(otherEdge.p2)) &&\n                edge.collinear(otherEdge)\n            ) {\n                return edge;\n            }\n        }\n\n        return null;\n    }\n\n    distanceToPoint(point) {\n        let shortest = Infinity;\n        for (const edge of this.edges()) {\n            let dist = edge.distanceToPoint(point);\n            if (dist < shortest) {\n                shortest = dist;\n            }\n        }\n        return shortest;\n    }\n\n    boundsSize() {\n        const [minx, miny, maxx, maxy] = this.bounds;\n        return { x: minx, y: miny, w: maxx - minx, h: maxy - miny };\n    }\n}\n\nexport class NavMesh {\n    constructor(polygons, costFunc = null, heuristicFunc = null, fromTolerance = 0, toTolerance = 0) {\n        this._uuid = uuidv4();\n        this.polygons = this._triangulate(polygons).map(\n            (points) => new Polygon(points)\n        );\n        this.costFunc = costFunc;\n        this.heuristicFunc = heuristicFunc;\n        this.fromTolerance = fromTolerance;\n        this.toTolerance = toTolerance;\n\n        // This will be used to check point collision with\n        // triangles. This should be much smaller that the typical\n        // size of your mesh triangles to avoid checking too many\n        // triangles for collision.\n        this.pointQuerySize = 0.01;\n\n        this._buildQuadtree();\n        this._buildNeighbors();\n    }\n\n    _triangulate(polygons) {\n        const triangles = [];\n        for (const poly of polygons) {\n            const trianglesIndices = earcut(this._flatten(poly));\n            for (let i = 0; i < trianglesIndices.length / 3; i++) {\n                const indices = trianglesIndices.slice(i * 3, i * 3 + 3);\n                triangles.push(indices.map((j) => poly[j]));\n            }\n        }\n        return triangles;\n    }\n\n    _flatten(points) {\n        const flatPoints = [];\n        for (const point of points) {\n            if (point instanceof Array) {\n                flatPoints.push(...point);\n            } else {\n                flatPoints.push(point.x, point.y);\n            }\n        }\n        return flatPoints;\n    }\n\n    _buildQuadtree() {\n        // Use quad tree because the naive approach of iterating\n        // with two nested for loops over the polygons has performance\n        // n*lon(n), which for a 30x30 grid already takes a minute.\n        // This thing, for the same grid, takes 1 second, and scales linearly.\n        this.qt = QuadTree(-Infinity, -Infinity, Infinity, Infinity);\n        for (const poly of this.polygons) {\n            this.qt.put({\n                ...poly.boundsSize(),\n                polygon: poly,\n            });\n        }\n    }\n\n    _buildNeighbors() {\n        this.polygons.forEach((polygon) => (polygon.neighbors = {}));\n\n        for (let i = 0; i < this.polygons.length; i++) {\n            const poly1 = this.polygons[i];\n\n            for (const poly2wrap of this.qt.get(poly1.boundsSize())) {\n                const poly2 = poly2wrap.polygon;\n\n                if (poly1 === poly2) continue;\n                if (poly1.neighbors.hasOwnProperty(poly2._uuid)) continue;\n\n                const portal = this._computePortal(poly1, poly2);\n                if (portal !== null && portal.length() > 0) {\n                    // Ensure that portal points are given in clockwise order, viewed from the centroid of the polygon\n                    let [p1, p2] = this._orderClockwise(poly1.centroid(), portal.p1, portal.p2);\n                    poly1.neighbors[poly2._uuid] = { polygon: poly2, portal: new Edge(p1, p2) };\n                    poly2.neighbors[poly1._uuid] = { polygon: poly1, portal: new Edge(p2, p1) };\n                }\n            }\n        }\n    }\n\n    _computePortal(poly1, poly2) {\n        for (const edge1 of poly1.edges()) {\n            const edge2 = poly2.touches(edge1);\n            if (edge2 !== null) {\n                return edge1.overlap(edge2);\n            }\n        }\n\n        return null;\n    }\n\n    findPath(from, to) {\n        from = _normalizePoint(from);\n        to = _normalizePoint(to);\n\n        const path = this._findPath(from, to);\n        return path && this._funnel(from, to, path);\n    }\n\n    _findPath(from, to) {\n        // This is the A* algorithm\n        const fromPoly = this._findClosestPolygon(from, this.fromTolerance);\n        const toPoly = this._findClosestPolygon(to, this.toTolerance);\n\n        if (fromPoly === null || toPoly === null) return null;\n\n        const frontier = new TinyQueue(\n            [{ cost: 0, polygon: fromPoly }],\n            (a, b) => a.cost - b.cost\n        );\n        const cameFrom = { [fromPoly._uuid]: null };\n        const cost = { [fromPoly._uuid]: 0 };\n\n        while (frontier.length) {\n            const current = frontier.pop().polygon;\n\n            if (current._uuid === toPoly._uuid) {\n                break;\n            }\n\n            for (const { polygon: next } of Object.values(current.neighbors)) {\n                const nextCost =\n                    cost[current._uuid] + this._computeCost(current, next);\n\n                if (\n                    // node not yet visited\n                    !cost.hasOwnProperty(next._uuid) ||\n                    // this path to node has lower cost\n                    nextCost < cost[next._uuid]\n                ) {\n                    frontier.push({\n                        cost: nextCost + this._heuristic(next, toPoly),\n                        polygon: next,\n                    });\n                    cost[next._uuid] = nextCost;\n                    cameFrom[next._uuid] = current;\n                }\n            }\n        }\n\n        return this._reconstructPath(toPoly, cameFrom);\n    }\n\n    _computeDistance(a, b) {\n        return a.centroidDistance(b);\n    }\n\n    _computeCost(a, b) {\n        if (this.costFunc !== null) {\n            const portal = a.neighbors[b._uuid].portal;\n            return this.costFunc(a, b, portal);\n        }\n        return this._computeDistance(a, b);\n    }\n\n    _heuristic(poly, to) {\n        if (poly._uuid == to._uuid) return 0;\n        if (this.heuristicFunc !== null) return this.heuristicFunc(poly, to);\n        return this._computeDistance(poly, to);\n    }\n\n    _findContainingPolygon(point) {\n        const halfQuerySize = this.pointQuerySize / 2;\n        const bounds = {\n            x: point.x - halfQuerySize,\n            y: point.y - halfQuerySize,\n            w: this.pointQuerySize,\n            h: this.pointQuerySize,\n        };\n        for (const poly of this.qt.get(bounds)) {\n            if (poly.polygon.contains(point)) return poly.polygon;\n        }\n\n        return null;\n    }\n\n    _findClosestPolygon(point, searchRadius) {\n        if (searchRadius < this.pointQuerySize / 2) {\n            return this._findContainingPolygon(point);\n        }\n\n        let containingPoly = this._findContainingPolygon(point);\n        if (containingPoly) return containingPoly;\n\n        const bounds = {\n            x: point.x - searchRadius / 2,\n            y: point.y - searchRadius / 2,\n            w: searchRadius,\n            h: searchRadius,\n        };\n        let closestDistance = Infinity;\n        let closestPoly = null;\n        for (const poly of this.qt.get(bounds)) {\n            let distance = poly.polygon.distanceToPoint(point);\n            console.log(distance)\n            if (distance < closestDistance) {\n                closestPoly = poly;\n                closestDistance = distance;\n            }\n        }\n\n        return closestPoly.polygon;\n    }\n\n    _reconstructPath(to, cameFrom) {\n        if (!cameFrom.hasOwnProperty(to._uuid)) {\n            // Disconnected\n            return null;\n        }\n\n        let current = to;\n\n        const path = [];\n        while (current !== null) {\n            path.push(current);\n            current = cameFrom[current._uuid];\n        }\n\n        return path.reverse();\n    }\n\n    /** Funnel algorithm, following https://medium.com/@reza.teshnizi/the-funnel-algorithm-explained-visually-41e374172d2d */\n    _funnel(from, to, path) {\n        if (path.length === 0) {\n            throw new Error(\"Path cannot be empty.\");\n        } else if (path.length === 1) {\n            return [from, to];\n        }\n\n        const tail = [from];\n        const left = [];\n        const right = [];\n\n        // Initialize funnel\n        const initialPortal = path[0].neighbors[path[1]._uuid].portal;\n        left.push(initialPortal.p1);\n        right.push(initialPortal.p2);\n\n        // Iterate over portals\n        for (let i = 1; i < path.length - 1; i++) {\n            const poly = path[i];\n            const nextPoly = path[i + 1];\n            const portal = poly.neighbors[nextPoly._uuid].portal;\n            // The portal end points are in clockwise order, viewed from the inside of the polygon.\n\n            // Extend funnel on the left\n            this._extendFunnel(tail, left, right, true, portal.p1);\n\n            // Extend funnel on the right\n            this._extendFunnel(tail, left, right, false, portal.p2);\n        }\n\n        // Close funnel to endpoint\n        this._extendFunnel(tail, left, right, true, to);\n        this._extendFunnel(tail, left, right, false, to);\n\n        return tail;\n    }\n\n    _extendFunnel(tail, left, right, extendLeft, newPoint){\n        const apex = tail[tail.length - 1];\n        // We pretend to be in the `expandLeft` case here. Otherwise flip.\n        if (!extendLeft) {\n            [left, right] = [right, left];\n        }\n\n        // If `newPoint` is the end point of the left side of the funnel, skip it.\n        const lastLeft = left.length === 0 ? tail[tail.length - 1] : left[left.length - 1];\n        if (newPoint.equals(lastLeft)) {\n            return;\n        }\n\n        // Determine angle of `apex`-`newPoint` relative to `apex`-`left[j]`\n        let j = 0;\n        while (j < left.length\n                && this._isInClockwiseOrder(apex, newPoint, left[j], !extendLeft)) {\n            j++;\n        }\n        // All points in `left` with index `< j` are right of `newPoint` and\n        // all points in `left` with index `>= j` are left of or at the same angle as `newPoint`. \n        left.length = j; // Shrink funnel if `j < left.length`\n        left.push(newPoint);\n        if (j === 0) {\n            // If the funnel shrunk all the way on the left, it might collapse to the right.\n            // Determine how far it needs to collapse\n            let k = 0;\n            while (k < right.length\n                    && !this._isInClockwiseOrder(apex, newPoint, right[k], !extendLeft)) {\n                k++;\n            }\n            // All points in `right` with index `< k` are left of or at the same angle as `newPoint` and\n            // all points in `right` with index `>= k` are right of `newPoint`. \n            tail.push(...right.splice(0, k)); // Collapse funnel if `k > 0`\n        }\n    }\n\n    /** \n     * Are the points `p1` and `p2` in clockwise order, viewed from `origin`?\n     * Checks for counter-clockwise order instead if `flip = true`.\n     * Returns `false` if the angles are equal.\n     */\n    _isInClockwiseOrder(origin, p1, p2, flip = false) {\n        if (flip) {\n            [p1, p2] = [p2, p1];\n        }\n        const vec1 = p1.sub(origin);\n        const vec2 = p2.sub(origin);\n        return cross(vec1, vec2) > 0;\n    }\n\n    /** Returns the points `p1` and `p2` in clockwise order, viewed from `origin`. */\n    _orderClockwise(origin, p1, p2) {\n        if (this._isInClockwiseOrder(origin, p1, p2)) {\n            return [p1, p2];\n        } else {\n            return [p2, p1];\n        }\n    }\n\n}\n","import { Vector, isclose, clip, dot, cross } from \"./math\";\nimport { Edge, Polygon, NavMesh } from \"./navmesh\";\n\nconst Point = Vector;\n\nexport { Point, Vector, isclose, clip, dot, cross, Edge, Polygon, NavMesh };\n"],"sourceRoot":""}