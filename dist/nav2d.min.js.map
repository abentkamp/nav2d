{"version":3,"sources":["webpack://nav2d/webpack/universalModuleDefinition","webpack://nav2d/webpack/bootstrap","webpack://nav2d/external {\"root\":\"uuid\",\"amd\":\"uuid\",\"commonjs2\":\"uuid\",\"commonjs\":\"uuid\"}","webpack://nav2d/external {\"root\":\"point-in-polygon\",\"amd\":\"point-in-polygon\",\"commonjs2\":\"point-in-polygon\",\"commonjs\":\"point-in-polygon\"}","webpack://nav2d/external {\"root\":\"earcut\",\"amd\":\"earcut\",\"commonjs2\":\"earcut\",\"commonjs\":\"earcut\"}","webpack://nav2d/external {\"root\":\"simple-quadtree\",\"amd\":\"simple-quadtree\",\"commonjs2\":\"simple-quadtree\",\"commonjs\":\"simple-quadtree\"}","webpack://nav2d/./src/math.js","webpack://nav2d/./node_modules/tinyqueue/index.js","webpack://nav2d/./src/navmesh.js","webpack://nav2d/./src/nav2d.js"],"names":["root","factory","exports","module","require","define","amd","self","this","__WEBPACK_EXTERNAL_MODULE__0__","__WEBPACK_EXTERNAL_MODULE__1__","__WEBPACK_EXTERNAL_MODULE__2__","__WEBPACK_EXTERNAL_MODULE__3__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Vector","x","y","Error","other","_normOther","Math","sqrt","isclose","acos","clip","dot","length","angle","cross","PI","a","b","eps","v","TinyQueue","data","compare","defaultCompare","_down","item","push","_up","top","bottom","pop","pos","parent","current","halfLength","left","best","right","_normalizePoint","point","Array","Edge","p1","p2","_uuid","uuidv4","sub","pointVec","parallel","direction","len","component","otherDirection","otherVec1","otherVec2","collinear","endpoints","onEdge","filter","findIndex","op","equals","Polygon","points","map","bounds","_computeBounds","reduce","min","max","Infinity","acc","add","div","centroid","polyPoints","_toPointArray","inside","edges","edge","otherEdge","minx","miny","w","h","NavMesh","polygons","costFunc","heuristicFunc","_triangulate","_buildQuadtree","_buildNeighbors","triangles","poly","trianglesIndices","earcut","_flatten","indices","slice","j","flatPoints","qt","QuadTree","put","boundsSize","polygon","forEach","neighbors","poly1","poly2","portal","_computePortal","edge1","edge2","touches","overlap","from","to","path","_findPath","_funnel","fromPoly","_findContainingPolygon","toPoly","frontier","cost","cameFrom","values","next","nextCost","_computeCost","_heuristic","_reconstructPath","centroidDistance","_computeDistance","halfSize","contains","reverse","_pointPortalEdges","newEdge1","newEdge2","_funnelEdge","newPath","_splitAt","toEdge","newToEdge","newStartIndex","indexOf","find","vec1","vec2","vector","Point"],"mappings":"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","file":"nav2d.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"uuid\"), require(\"point-in-polygon\"), require(\"earcut\"), require(\"simple-quadtree\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"uuid\", \"point-in-polygon\", \"earcut\", \"simple-quadtree\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"nav2d\"] = factory(require(\"uuid\"), require(\"point-in-polygon\"), require(\"earcut\"), require(\"simple-quadtree\"));\n\telse\n\t\troot[\"nav2d\"] = factory(root[\"uuid\"], root[\"point-in-polygon\"], root[\"earcut\"], root[\"simple-quadtree\"]);\n})((typeof self !== 'undefined' ? self : this), function(__WEBPACK_EXTERNAL_MODULE__0__, __WEBPACK_EXTERNAL_MODULE__1__, __WEBPACK_EXTERNAL_MODULE__2__, __WEBPACK_EXTERNAL_MODULE__3__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","module.exports = __WEBPACK_EXTERNAL_MODULE__1__;","module.exports = __WEBPACK_EXTERNAL_MODULE__2__;","module.exports = __WEBPACK_EXTERNAL_MODULE__3__;","export const EPS = 1e-8;\n\nexport class Vector {\n    constructor(x, y) {\n        if (typeof x !== \"number\" || typeof y !== \"number\") {\n            throw new Error(\"Vector components must be numbers.\");\n        }\n\n        this.x = x;\n        this.y = y;\n    }\n\n    _normOther(other) {\n        if (typeof other == \"number\") {\n            return new Vector(other, other);\n        }\n        return other;\n    }\n\n    add(other) {\n        other = this._normOther(other);\n        return new Vector(this.x + other.x, this.y + other.y);\n    }\n\n    sub(other) {\n        other = this._normOther(other);\n        return new Vector(this.x - other.x, this.y - other.y);\n    }\n\n    mul(other) {\n        other = this._normOther(other);\n        return new Vector(this.x * other.x, this.y * other.y);\n    }\n\n    div(other) {\n        other = this._normOther(other);\n        return new Vector(this.x / other.x, this.y / other.y);\n    }\n\n    length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n\n    equals(other) {\n        return isclose(this.x, other.x) && isclose(this.y, other.y);\n    }\n\n    angle(other) {\n        return Math.acos(\n            clip(-1, 1, dot(this, other) / (this.length() * other.length()))\n        );\n    }\n\n    counterclockwiseAngle(other) {\n        const angle = this.angle(other);\n        return cross(this, other) >= 0 ? angle : 2 * Math.PI - angle;\n    }\n\n    toString() {\n        return `{ x: ${this.x}, y: ${this.y} }`;\n    }\n}\n\nexport function dot(a, b) {\n    return a.x * b.x + a.y * b.y;\n}\n\nexport function cross(a, b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nexport function isclose(a, b, eps = EPS) {\n    return a > b - eps && a < b + eps;\n}\n\nexport function clip(a, b, v) {\n    if (v < a) return a;\n    if (v > b) return b;\n    return v;\n}\n","\nexport default class TinyQueue {\n    constructor(data = [], compare = defaultCompare) {\n        this.data = data;\n        this.length = this.data.length;\n        this.compare = compare;\n\n        if (this.length > 0) {\n            for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);\n        }\n    }\n\n    push(item) {\n        this.data.push(item);\n        this.length++;\n        this._up(this.length - 1);\n    }\n\n    pop() {\n        if (this.length === 0) return undefined;\n\n        const top = this.data[0];\n        const bottom = this.data.pop();\n        this.length--;\n\n        if (this.length > 0) {\n            this.data[0] = bottom;\n            this._down(0);\n        }\n\n        return top;\n    }\n\n    peek() {\n        return this.data[0];\n    }\n\n    _up(pos) {\n        const {data, compare} = this;\n        const item = data[pos];\n\n        while (pos > 0) {\n            const parent = (pos - 1) >> 1;\n            const current = data[parent];\n            if (compare(item, current) >= 0) break;\n            data[pos] = current;\n            pos = parent;\n        }\n\n        data[pos] = item;\n    }\n\n    _down(pos) {\n        const {data, compare} = this;\n        const halfLength = this.length >> 1;\n        const item = data[pos];\n\n        while (pos < halfLength) {\n            let left = (pos << 1) + 1;\n            let best = data[left];\n            const right = left + 1;\n\n            if (right < this.length && compare(data[right], best) < 0) {\n                left = right;\n                best = data[right];\n            }\n            if (compare(best, item) >= 0) break;\n\n            data[pos] = best;\n            pos = left;\n        }\n\n        data[pos] = item;\n    }\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n","import { v4 as uuidv4 } from \"uuid\";\nimport inside from \"point-in-polygon\";\nimport earcut from \"earcut\";\nimport QuadTree from \"simple-quadtree\";\nimport TinyQueue from \"tinyqueue\";\n\nimport { Vector, isclose, cross, dot } from \"./math\";\n\nfunction _normalizePoint(point) {\n    if (point instanceof Array) {\n        return new Vector(...point);\n    } else if (point instanceof Vector) {\n        return point;\n    } else if (point.hasOwnProperty(\"x\") && point.hasOwnProperty(\"y\")) {\n        return new Vector(point.x, point.y);\n    }\n}\n\nexport class Edge {\n    constructor(p1, p2) {\n        this._uuid = uuidv4();\n        this.p1 = _normalizePoint(p1);\n        this.p2 = _normalizePoint(p2);\n    }\n\n    length() {\n        return this.p1.sub(this.p2).length();\n    }\n\n    direction() {\n        return this.p1.sub(this.p2);\n    }\n\n    onEdge(point) {\n        point = _normalizePoint(point);\n        const pointVec = this.p1.sub(point);\n\n        if (!this.parallel(pointVec)) return false;\n\n        // test that it's not only collinear, but falls between p1 and p2\n        const direction = this.direction();\n        const len = this.length();\n        const component = dot(direction, pointVec) / (len * len);\n        return component >= 0 && component <= 1;\n    }\n\n    parallel(other) {\n        const otherDirection =\n            other instanceof Vector ? other : other.p1.sub(other.p2);\n        return isclose(cross(this.direction(), otherDirection), 0);\n    }\n\n    collinear(other) {\n        const direction = this.direction();\n        const otherVec1 = this.p1.sub(other.p1);\n        const otherVec2 = this.p1.sub(other.p2);\n        return (\n            isclose(cross(direction, otherVec1), 0) &&\n            isclose(cross(direction, otherVec2), 0)\n        );\n    }\n\n    overlap(other) {\n        if (!this.collinear(other)) {\n            throw new Error(\n                \"Cannot compute overlap of two non-collinear edges.\"\n            );\n        }\n\n        let endpoints = [];\n\n        if (this.onEdge(other.p1)) endpoints.push(other.p1);\n        if (this.onEdge(other.p2)) endpoints.push(other.p2);\n        if (other.onEdge(this.p1)) endpoints.push(this.p1);\n        if (other.onEdge(this.p2)) endpoints.push(this.p2);\n\n        // enpoints can also be the an array with twice the same point,\n        // which is fine as it yields a zero-length edge\n        if (endpoints.length > 2) {\n            endpoints = endpoints.filter(\n                (p, i) => endpoints.findIndex((op) => op.equals(p)) === i\n            );\n        }\n\n        if (!endpoints.length) {\n            return null;\n        } else if (endpoints.length == 1) {\n            endpoints = [endpoints[0], endpoints[0]];\n        }\n\n        return new Edge(...endpoints);\n    }\n\n    equals(other) {\n        return (\n            (this.p1.equals(other.p1) && this.p2.equals(other.p2)) ||\n            (this.p1.equals(other.p2) && this.p2.equals(other.p1))\n        );\n    }\n}\n\nexport class Polygon {\n    constructor(points) {\n        this._uuid = uuidv4();\n        this.points = points.map(_normalizePoint);\n        this.bounds = this._computeBounds();\n    }\n\n    _computeBounds() {\n        return this.points.reduce(\n            (a, p) => [\n                Math.min(p.x, a[0]),\n                Math.min(p.y, a[1]),\n                Math.max(p.x, a[2]),\n                Math.max(p.y, a[3]),\n            ],\n            [Infinity, Infinity, -Infinity, -Infinity]\n        );\n    }\n\n    edges() {\n        return this.points.map(\n            (point, i) =>\n                new Edge(\n                    i == 0\n                        ? this.points[this.points.length - 1]\n                        : this.points[i - 1],\n                    point\n                )\n        );\n    }\n\n    centroid() {\n        return this.points\n            .reduce((acc, point) => acc.add(point), new Vector(0, 0))\n            .div(this.points.length);\n    }\n\n    centroidDistance(other) {\n        const centroidVector = this.centroid().sub(other.centroid());\n        return centroidVector.length();\n    }\n\n    contains(point) {\n        point = _normalizePoint(point);\n        const polyPoints = this.points.map(this._toPointArray);\n        return (\n            inside(this._toPointArray(point), polyPoints) ||\n            !!this.onEdge(point)\n        );\n    }\n\n    _toPointArray(point) {\n        return [point.x, point.y];\n    }\n\n    onEdge(point) {\n        point = _normalizePoint(point);\n        for (const edge of this.edges()) {\n            if (edge.onEdge(point)) return edge;\n        }\n\n        return null;\n    }\n\n    touches(otherEdge) {\n        for (const edge of this.edges()) {\n            if (\n                (edge.onEdge(otherEdge.p1) || edge.onEdge(otherEdge.p2)) &&\n                edge.collinear(otherEdge)\n            ) {\n                return edge;\n            }\n        }\n\n        return null;\n    }\n\n    boundsSize() {\n        const [minx, miny, maxx, maxy] = this.bounds;\n        return { x: minx, y: miny, w: maxx - minx, h: maxy - miny };\n    }\n}\n\nexport class NavMesh {\n    constructor(polygons, costFunc = null, heuristicFunc = null) {\n        this._uuid = uuidv4();\n        this.polygons = this._triangulate(polygons).map(\n            (points) => new Polygon(points)\n        );\n        this.costFunc = costFunc;\n        this.heuristicFunc = heuristicFunc;\n\n        this._buildQuadtree();\n        this._buildNeighbors();\n    }\n\n    _triangulate(polygons) {\n        const triangles = [];\n        for (const poly of polygons) {\n            const trianglesIndices = earcut(this._flatten(poly));\n            for (let i = 0; i < trianglesIndices.length / 3; i++) {\n                const indices = trianglesIndices.slice(i * 3, i * 3 + 3);\n                triangles.push(indices.map((j) => poly[j]));\n            }\n        }\n        return triangles;\n    }\n\n    _flatten(points) {\n        const flatPoints = [];\n        for (const point of points) {\n            if (point instanceof Array) {\n                flatPoints.push(...point);\n            } else {\n                flatPoints.push(point.x, point.y);\n            }\n        }\n        return flatPoints;\n    }\n\n    _buildQuadtree() {\n        // Use quad tree because the naive approach of iterating\n        // with two nested for loops over the polygons has performance\n        // n*lon(n), which for a 30x30 grid already takes a minute.\n        // This thing, for the same grid, takes 1 second, and scales linearly.\n        this.qt = QuadTree(-Infinity, -Infinity, Infinity, Infinity);\n        for (const poly of this.polygons) {\n            this.qt.put({\n                ...poly.boundsSize(),\n                polygon: poly,\n            });\n        }\n    }\n\n    _buildNeighbors() {\n        this.polygons.forEach((polygon) => (polygon.neighbors = {}));\n\n        for (let i = 0; i < this.polygons.length; i++) {\n            const poly1 = this.polygons[i];\n\n            for (const poly2wrap of this.qt.get(poly1.boundsSize())) {\n                const poly2 = poly2wrap.polygon;\n\n                if (poly1 === poly2) continue;\n                if (poly1.neighbors.hasOwnProperty(poly2._uuid)) continue;\n\n                const portal = this._computePortal(poly1, poly2);\n                if (portal !== null && portal.length() > 0) {\n                    poly1.neighbors[poly2._uuid] = { polygon: poly2, portal };\n                    poly2.neighbors[poly1._uuid] = { polygon: poly1, portal };\n                }\n            }\n        }\n    }\n\n    _computePortal(poly1, poly2) {\n        for (const edge1 of poly1.edges()) {\n            const edge2 = poly2.touches(edge1);\n            if (edge2 !== null) {\n                return edge1.overlap(edge2);\n            }\n        }\n\n        return null;\n    }\n\n    findPath(from, to) {\n        from = _normalizePoint(from);\n        to = _normalizePoint(to);\n\n        const path = this._findPath(from, to);\n        return path && this._funnel(from, to, path);\n    }\n\n    _findPath(from, to) {\n        // This is the A* algorithm\n        const fromPoly = this._findContainingPolygon(from);\n        const toPoly = this._findContainingPolygon(to);\n\n        if (fromPoly === null || toPoly === null) return null;\n\n        const frontier = new TinyQueue(\n            [{ cost: 0, polygon: fromPoly }],\n            (a, b) => a.cost - b.cost\n        );\n        const cameFrom = { [fromPoly._uuid]: null };\n        const cost = { [fromPoly._uuid]: 0 };\n\n        while (frontier.length) {\n            const current = frontier.pop().polygon;\n\n            if (current._uuid === toPoly._uuid) {\n                break;\n            }\n\n            for (const { polygon: next } of Object.values(current.neighbors)) {\n                const nextCost =\n                    cost[current._uuid] + this._computeCost(current, next);\n\n                if (\n                    // node not yet visited\n                    !cost.hasOwnProperty(next._uuid) ||\n                    // this path to node has lower cost\n                    nextCost < cost[next._uuid]\n                ) {\n                    frontier.push({\n                        cost: nextCost + this._heuristic(next, toPoly),\n                        polygon: next,\n                    });\n                    cost[next._uuid] = nextCost;\n                    cameFrom[next._uuid] = current;\n                }\n            }\n        }\n\n        return this._reconstructPath(toPoly, cameFrom);\n    }\n\n    _computeDistance(a, b) {\n        return a.centroidDistance(b);\n    }\n\n    _computeCost(a, b) {\n        if (this.costFunc !== null) {\n            const portal = a.neighbors[b._uuid].portal;\n            return this.costFunc(a, b, portal);\n        }\n        return this._computeDistance(a, b);\n    }\n\n    _heuristic(poly, to) {\n        if (poly._uuid == to._uuid) return 0;\n        if (this.heuristicFunc !== null) return this.heuristicFunc(poly, to);\n        return this._computeDistance(poly, to);\n    }\n\n    _findContainingPolygon(point) {\n        const halfSize = point.x * 0.01;\n        const bounds = {\n            x: point.x * 0.99 - halfSize,\n            y: point.y * 0.99 - halfSize,\n            w: 2 * halfSize,\n            h: 2 * halfSize,\n        };\n        for (const poly of this.qt.get(bounds)) {\n            if (poly.polygon.contains(point)) return poly.polygon;\n        }\n\n        return null;\n    }\n\n    _reconstructPath(to, cameFrom) {\n        if (!cameFrom.hasOwnProperty(to._uuid)) {\n            // Disconnected\n            return null;\n        }\n\n        let current = to;\n\n        const path = [];\n        while (current !== null) {\n            path.push(current);\n            current = cameFrom[current._uuid];\n        }\n\n        return path.reverse();\n    }\n\n    _funnel(from, to, path) {\n        if (path.length === 0) {\n            throw new Error(\"Path cannot be empty.\");\n        } else if (path.length === 1) {\n            return [from, to];\n        }\n\n        const points = [from];\n        let edge1 = null;\n        let edge2 = null;\n\n        for (let i = 0; i < path.length - 1; i++) {\n            const poly = path[i];\n            const next = path[i + 1];\n            const portal = poly.neighbors[next._uuid].portal;\n\n            // Calculate portal edges\n            let [newEdge1, newEdge2] = this._pointPortalEdges(from, portal);\n\n            if (edge1 !== null && edge2 !== null) {\n                // Shrink funnel edges\n                newEdge1 = this._funnelEdge(edge1, edge2, newEdge1);\n                newEdge2 = this._funnelEdge(edge2, edge1, newEdge2);\n\n                if (newEdge1 === null || newEdge2 === null) {\n                    const edge = newEdge1 === null ? edge2 : edge1;\n                    const newPath = this._splitAt(\n                        // We only need to check the polygon up to now, not the future\n                        // ones. This can have serious performance implications,\n                        // as the function is recursive.\n                        path.slice(i - 1),\n                        edge.p2\n                    );\n                    points.push(...this._funnel(edge.p2, to, newPath));\n                    break;\n                }\n            }\n\n            edge1 = newEdge1;\n            edge2 = newEdge2;\n\n            // If we are at the end of the path,\n            // just add the last edge, which is from -> to\n            if (i === path.length - 2) {\n                const toEdge = new Edge(from, to);\n                let newToEdge = this._funnelEdge(edge1, edge2, toEdge);\n                if (newToEdge === edge1) {\n                    points.push(edge1.p2);\n                } else if (newToEdge === null) {\n                    points.push(edge2.p2);\n                }\n\n                points.push(to);\n            }\n        }\n\n        return points;\n    }\n\n    _pointPortalEdges(point, portal) {\n        const vec1 = portal.p1.sub(point);\n        const vec2 = portal.p2.sub(point);\n        // The funnel is between vec1 and vec2 in\n        // counterclockwise direction, so the ordering counts.\n        // and can be assessed with the sign of the\n        // cross product.\n        if (cross(vec1, vec2) < 0) {\n            return [new Edge(point, portal.p2), new Edge(point, portal.p1)];\n        } else {\n            return [new Edge(point, portal.p1), new Edge(point, portal.p2)];\n        }\n    }\n\n    _splitAt(path, point) {\n        const newStartIndex = path.indexOf(\n            // Reverse changes the array in-place\n            [...path].reverse().find((p) => p.contains(point))\n        );\n        return path.slice(newStartIndex);\n    }\n\n    _funnelEdge(edge1, edge2, edge) {\n        const vec1 = edge1.direction();\n        const vec2 = edge2.direction();\n        const vector = edge.direction();\n        // If the cross product has different sign,\n        // the vector would enlarge the funnel\n        // -> return current vector as funnel edge.\n        if (cross(vec1, vec2) * cross(vec1, vector) < 0) return edge1;\n        // If the vector is inside the funnel, shrink funnel.\n        if (vec1.angle(vector) <= vec1.angle(vec2)) return edge;\n        // Vector would close the funnel, return null.\n        return null;\n    }\n}\n","import { Vector, isclose, clip, dot, cross } from \"./math\";\nimport { Edge, Polygon, NavMesh } from \"./navmesh\";\n\nconst Point = Vector;\n\nexport { Point, Vector, isclose, clip, dot, cross, Edge, Polygon, NavMesh };\n"],"sourceRoot":""}