{"version":3,"sources":["webpack://nav2d/webpack/universalModuleDefinition","webpack://nav2d/webpack/bootstrap","webpack://nav2d/external {\"root\":\"uuid\",\"amd\":\"uuid\",\"commonjs2\":\"uuid\",\"commonjs\":\"uuid\"}","webpack://nav2d/external {\"root\":\"point-in-polygon\",\"amd\":\"point-in-polygon\",\"commonjs2\":\"point-in-polygon\",\"commonjs\":\"point-in-polygon\"}","webpack://nav2d/external {\"root\":\"earcut\",\"amd\":\"earcut\",\"commonjs2\":\"earcut\",\"commonjs\":\"earcut\"}","webpack://nav2d/external {\"root\":\"simple-quadtree\",\"amd\":\"simple-quadtree\",\"commonjs2\":\"simple-quadtree\",\"commonjs\":\"simple-quadtree\"}","webpack://nav2d/./src/math.js","webpack://nav2d/./node_modules/tinyqueue/index.js","webpack://nav2d/./src/navmesh.js","webpack://nav2d/./src/nav2d.js"],"names":["root","factory","exports","module","require","define","amd","self","this","__WEBPACK_EXTERNAL_MODULE__0__","__WEBPACK_EXTERNAL_MODULE__1__","__WEBPACK_EXTERNAL_MODULE__2__","__WEBPACK_EXTERNAL_MODULE__3__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Vector","x","y","Error","other","_normOther","Math","sqrt","isclose","acos","clip","dot","length","angle","cross","PI","a","b","eps","v","TinyQueue","data","compare","defaultCompare","_down","item","push","_up","top","bottom","pop","pos","parent","current","halfLength","left","best","right","_normalizePoint","point","Array","Edge","p1","p2","_uuid","uuidv4","sub","pointVec","parallel","direction","len","component","otherDirection","otherVec1","otherVec2","collinear","endpoints","onEdge","filter","findIndex","op","equals","squaredLength","Polygon","points","group","map","bounds","_computeBounds","reduce","min","max","Infinity","acc","add","div","centroid","polyPoints","_toPointArray","inside","edges","edge","otherEdge","shortest","dist","distanceToPoint","minx","miny","w","h","NavMesh","polygons","costFunc","heuristicFunc","fromTolerance","toTolerance","_triangulate","pointQuerySize","_buildQuadtree","_buildNeighbors","isArray","default","triangles","poly","_flatten","vertices","holes","trianglesIndices","earcut","indices","slice","j","undefined","result","holeIndex","qt","QuadTree","put","boundsSize","polygon","forEach","neighbors","poly1","poly2","portal","_computePortal","_orderLeftRight","edge1","edge2","touches","overlap","from","to","groups","path","_findPath","_funnel","fromPoly","_findClosestPolygon","toPoly","frontier","cost","cameFrom","values","next","includes","nextCost","_computeCost","_heuristic","_reconstructPath","centroidDistance","_computeDistance","halfQuerySize","contains","searchRadius","_findContainingPolygon","containingPoly","closestDistance","closestPoly","distance","reverse","tail","initialPortal","nextPoly","_extendFunnel","leftPoint","rightPoint","_extendFunnelSide","extendLeft","newPoint","apex","lastLeft","_findFirstLeftOfPoint","k","splice","origin","arr","acceptColinear","flip","_isInLeftRightOrder","vec1","vec2","Point"],"mappings":"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","file":"nav2d.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"uuid\"), require(\"point-in-polygon\"), require(\"earcut\"), require(\"simple-quadtree\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"uuid\", \"point-in-polygon\", \"earcut\", \"simple-quadtree\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"nav2d\"] = factory(require(\"uuid\"), require(\"point-in-polygon\"), require(\"earcut\"), require(\"simple-quadtree\"));\n\telse\n\t\troot[\"nav2d\"] = factory(root[\"uuid\"], root[\"point-in-polygon\"], root[\"earcut\"], root[\"simple-quadtree\"]);\n})((typeof self !== 'undefined' ? self : this), function(__WEBPACK_EXTERNAL_MODULE__0__, __WEBPACK_EXTERNAL_MODULE__1__, __WEBPACK_EXTERNAL_MODULE__2__, __WEBPACK_EXTERNAL_MODULE__3__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","module.exports = __WEBPACK_EXTERNAL_MODULE__1__;","module.exports = __WEBPACK_EXTERNAL_MODULE__2__;","module.exports = __WEBPACK_EXTERNAL_MODULE__3__;","export const EPS = 1e-8;\n\nexport class Vector {\n    constructor(x, y) {\n        if (typeof x !== \"number\" || typeof y !== \"number\") {\n            throw new Error(\"Vector components must be numbers.\");\n        }\n\n        this.x = x;\n        this.y = y;\n    }\n\n    _normOther(other) {\n        if (typeof other == \"number\") {\n            return new Vector(other, other);\n        }\n        return other;\n    }\n\n    add(other) {\n        other = this._normOther(other);\n        return new Vector(this.x + other.x, this.y + other.y);\n    }\n\n    sub(other) {\n        other = this._normOther(other);\n        return new Vector(this.x - other.x, this.y - other.y);\n    }\n\n    mul(other) {\n        other = this._normOther(other);\n        return new Vector(this.x * other.x, this.y * other.y);\n    }\n\n    div(other) {\n        other = this._normOther(other);\n        return new Vector(this.x / other.x, this.y / other.y);\n    }\n\n    length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n\n    equals(other) {\n        return isclose(this.x, other.x) && isclose(this.y, other.y);\n    }\n\n    angle(other) {\n        return Math.acos(\n            clip(-1, 1, dot(this, other) / (this.length() * other.length()))\n        );\n    }\n\n    counterclockwiseAngle(other) {\n        const angle = this.angle(other);\n        return cross(this, other) >= 0 ? angle : 2 * Math.PI - angle;\n    }\n\n    toString() {\n        return `{ x: ${this.x}, y: ${this.y} }`;\n    }\n}\n\nexport function dot(a, b) {\n    return a.x * b.x + a.y * b.y;\n}\n\nexport function cross(a, b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nexport function isclose(a, b, eps = EPS) {\n    return a > b - eps && a < b + eps;\n}\n\nexport function clip(a, b, v) {\n    if (v < a) return a;\n    if (v > b) return b;\n    return v;\n}\n","\nexport default class TinyQueue {\n    constructor(data = [], compare = defaultCompare) {\n        this.data = data;\n        this.length = this.data.length;\n        this.compare = compare;\n\n        if (this.length > 0) {\n            for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);\n        }\n    }\n\n    push(item) {\n        this.data.push(item);\n        this.length++;\n        this._up(this.length - 1);\n    }\n\n    pop() {\n        if (this.length === 0) return undefined;\n\n        const top = this.data[0];\n        const bottom = this.data.pop();\n        this.length--;\n\n        if (this.length > 0) {\n            this.data[0] = bottom;\n            this._down(0);\n        }\n\n        return top;\n    }\n\n    peek() {\n        return this.data[0];\n    }\n\n    _up(pos) {\n        const {data, compare} = this;\n        const item = data[pos];\n\n        while (pos > 0) {\n            const parent = (pos - 1) >> 1;\n            const current = data[parent];\n            if (compare(item, current) >= 0) break;\n            data[pos] = current;\n            pos = parent;\n        }\n\n        data[pos] = item;\n    }\n\n    _down(pos) {\n        const {data, compare} = this;\n        const halfLength = this.length >> 1;\n        const item = data[pos];\n\n        while (pos < halfLength) {\n            let left = (pos << 1) + 1;\n            let best = data[left];\n            const right = left + 1;\n\n            if (right < this.length && compare(data[right], best) < 0) {\n                left = right;\n                best = data[right];\n            }\n            if (compare(best, item) >= 0) break;\n\n            data[pos] = best;\n            pos = left;\n        }\n\n        data[pos] = item;\n    }\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n","import { v4 as uuidv4 } from \"uuid\";\nimport inside from \"point-in-polygon\";\nimport earcut from \"earcut\";\nimport QuadTree from \"simple-quadtree\";\nimport TinyQueue from \"tinyqueue\";\n\nimport { Vector, isclose, cross, dot } from \"./math\";\n\nfunction _normalizePoint(point) {\n    if (point instanceof Array) {\n        return new Vector(...point);\n    } else if (point instanceof Vector) {\n        return point;\n    } else if (point.hasOwnProperty(\"x\") && point.hasOwnProperty(\"y\")) {\n        return new Vector(point.x, point.y);\n    }\n}\n\nexport class Edge {\n    constructor(p1, p2) {\n        this._uuid = uuidv4();\n        this.p1 = _normalizePoint(p1);\n        this.p2 = _normalizePoint(p2);\n    }\n\n    length() {\n        return this.p1.sub(this.p2).length();\n    }\n\n    direction() {\n        return this.p1.sub(this.p2);\n    }\n\n    onEdge(point) {\n        point = _normalizePoint(point);\n        const pointVec = this.p1.sub(point);\n\n        if (!this.parallel(pointVec)) return false;\n\n        // test that it's not only collinear, but falls between p1 and p2\n        const direction = this.direction();\n        const len = this.length();\n        const component = dot(direction, pointVec) / (len * len);\n        return component >= 0 && component <= 1;\n    }\n\n    parallel(other) {\n        const otherDirection =\n            other instanceof Vector ? other : other.p1.sub(other.p2);\n        return isclose(cross(this.direction(), otherDirection), 0);\n    }\n\n    collinear(other) {\n        const direction = this.direction();\n        const otherVec1 = this.p1.sub(other.p1);\n        const otherVec2 = this.p1.sub(other.p2);\n        return (\n            isclose(cross(direction, otherVec1), 0) &&\n            isclose(cross(direction, otherVec2), 0)\n        );\n    }\n\n    overlap(other) {\n        if (!this.collinear(other)) {\n            throw new Error(\n                \"Cannot compute overlap of two non-collinear edges.\"\n            );\n        }\n\n        let endpoints = [];\n\n        if (this.onEdge(other.p1)) endpoints.push(other.p1);\n        if (this.onEdge(other.p2)) endpoints.push(other.p2);\n        if (other.onEdge(this.p1)) endpoints.push(this.p1);\n        if (other.onEdge(this.p2)) endpoints.push(this.p2);\n\n        // enpoints can also be the an array with twice the same point,\n        // which is fine as it yields a zero-length edge\n        if (endpoints.length > 2) {\n            endpoints = endpoints.filter(\n                (p, i) => endpoints.findIndex((op) => op.equals(p)) === i\n            );\n        }\n\n        if (!endpoints.length) {\n            return null;\n        } else if (endpoints.length == 1) {\n            endpoints = [endpoints[0], endpoints[0]];\n        }\n\n        return new Edge(...endpoints);\n    }\n\n    distanceToPoint(point) {\n        let squaredLength = dot(this.p2.sub(this.p1), this.p2.sub(this.p1));\n        let r = dot(this.p2.sub(this.p1), point.sub(this.p1));\n        r /= squaredLength;\n\n        if (r < 0) {\n            return point.sub(this.p1).length();\n        } else if (r > 1) {\n            return point.sub(this.p2).length();\n        } else {\n            return Math.sqrt(dot(point.sub(this.p1), point.sub(this.p1)) - r * r * squaredLength);\n        }\n    }\n\n    equals(other) {\n        return (\n            (this.p1.equals(other.p1) && this.p2.equals(other.p2)) ||\n            (this.p1.equals(other.p2) && this.p2.equals(other.p1))\n        );\n    }\n}\n\nexport class Polygon {\n    constructor(points, group = \"default\") {\n        this._uuid = uuidv4();\n        this.points = points.map(_normalizePoint);\n        this.bounds = this._computeBounds();\n        this.group = group;\n    }\n\n    _computeBounds() {\n        return this.points.reduce(\n            (a, p) => [\n                Math.min(p.x, a[0]),\n                Math.min(p.y, a[1]),\n                Math.max(p.x, a[2]),\n                Math.max(p.y, a[3]),\n            ],\n            [Infinity, Infinity, -Infinity, -Infinity]\n        );\n    }\n\n    edges() {\n        return this.points.map(\n            (point, i) =>\n                new Edge(\n                    i == 0\n                        ? this.points[this.points.length - 1]\n                        : this.points[i - 1],\n                    point\n                )\n        );\n    }\n\n    centroid() {\n        return this.points\n            .reduce((acc, point) => acc.add(point), new Vector(0, 0))\n            .div(this.points.length);\n    }\n\n    centroidDistance(other) {\n        const centroidVector = this.centroid().sub(other.centroid());\n        return centroidVector.length();\n    }\n\n    contains(point) {\n        point = _normalizePoint(point);\n        const polyPoints = this.points.map(this._toPointArray);\n        return (\n            inside(this._toPointArray(point), polyPoints) ||\n            !!this.onEdge(point)\n        );\n    }\n\n    _toPointArray(point) {\n        return [point.x, point.y];\n    }\n\n    onEdge(point) {\n        point = _normalizePoint(point);\n        for (const edge of this.edges()) {\n            if (edge.onEdge(point)) return edge;\n        }\n\n        return null;\n    }\n\n    touches(otherEdge) {\n        for (const edge of this.edges()) {\n            if (\n                (edge.onEdge(otherEdge.p1) || edge.onEdge(otherEdge.p2)) &&\n                edge.collinear(otherEdge)\n            ) {\n                return edge;\n            }\n        }\n\n        return null;\n    }\n\n    distanceToPoint(point) {\n        let shortest = Infinity;\n        for (const edge of this.edges()) {\n            let dist = edge.distanceToPoint(point);\n            if (dist < shortest) {\n                shortest = dist;\n            }\n        }\n        return shortest;\n    }\n\n    boundsSize() {\n        const [minx, miny, maxx, maxy] = this.bounds;\n        return { x: minx, y: miny, w: maxx - minx, h: maxy - miny };\n    }\n}\n\nexport class NavMesh {\n    constructor(polygons, costFunc = null, heuristicFunc = null, fromTolerance = 0, toTolerance = 0) {\n        this._uuid = uuidv4();\n        this.polygons = this._triangulate(polygons)\n        this.costFunc = costFunc;\n        this.heuristicFunc = heuristicFunc;\n        this.fromTolerance = fromTolerance;\n        this.toTolerance = toTolerance;\n\n        // This will be used to check point collision with\n        // triangles. This should be much smaller that the typical\n        // size of your mesh triangles to avoid checking too many\n        // triangles for collision.\n        this.pointQuerySize = 0.01;\n\n        this._buildQuadtree();\n        this._buildNeighbors();\n    }\n\n    _triangulate(polygons) {\n        // Normalize input\n        if (Array.isArray(polygons)) {\n            polygons = {default: polygons};\n        }\n\n        //Triangulate\n        const triangles = [];\n        for (const group in polygons) {\n            for (const poly of polygons[group]) {\n                const { vertices, holes } = this._flatten(poly);\n                const trianglesIndices = earcut(vertices, holes);\n                for (let i = 0; i < trianglesIndices.length / 3; i++) {\n                    const indices = trianglesIndices.slice(i * 3, i * 3 + 3);\n                    triangles.push(\n                        new Polygon(\n                            indices.map((j) => new Vector(vertices[2 * j], vertices[2 * j + 1])),\n                            group\n                        )\n                    );\n                }\n            }\n        }\n        return triangles;\n    }\n\n    _flatten(data) {\n        // Normalize input\n        if (data[0].x !== undefined || typeof data[0][0] === \"number\") {\n            // Polygon without holes\n            data = [data];\n        }\n\n        // Flatten\n        let result = { vertices: [], holes: [] };\n        let holeIndex = 0;\n\n        for (let i = 0; i < data.length; i++) {\n            for (let point of data[i]) {\n                if (point instanceof Array) {\n                    result.vertices.push(...point);\n                } else {\n                    result.vertices.push(point.x, point.y);\n                }\n            }\n            if (i > 0) {\n                holeIndex += data[i - 1].length;\n                result.holes.push(holeIndex);\n            }\n        }\n        return result;\n    }\n\n    _buildQuadtree() {\n        // Use quad tree because the naive approach of iterating\n        // with two nested for loops over the polygons has performance\n        // n*lon(n), which for a 30x30 grid already takes a minute.\n        // This thing, for the same grid, takes 1 second, and scales linearly.\n        this.qt = QuadTree(-Infinity, -Infinity, Infinity, Infinity);\n        for (const poly of this.polygons) {\n            this.qt.put({\n                ...poly.boundsSize(),\n                polygon: poly,\n            });\n        }\n    }\n\n    _buildNeighbors() {\n        this.polygons.forEach((polygon) => (polygon.neighbors = {}));\n\n        for (let i = 0; i < this.polygons.length; i++) {\n            const poly1 = this.polygons[i];\n\n            for (const poly2wrap of this.qt.get(poly1.boundsSize())) {\n                const poly2 = poly2wrap.polygon;\n\n                if (poly1 === poly2) continue;\n                if (poly1.neighbors.hasOwnProperty(poly2._uuid)) continue;\n\n                const portal = this._computePortal(poly1, poly2);\n                if (portal !== null && portal.length() > 0) {\n                    // Ensure that portal points are given in left-to-right order, viewed from the centroid of the polygon\n                    let [p1, p2] = this._orderLeftRight(\n                        poly1.centroid(),\n                        portal.p1,\n                        portal.p2\n                    );\n                    poly1.neighbors[poly2._uuid] = {\n                        polygon: poly2,\n                        portal: new Edge(p1, p2),\n                    };\n                    poly2.neighbors[poly1._uuid] = {\n                        polygon: poly1,\n                        portal: new Edge(p2, p1),\n                    };\n                }\n            }\n        }\n    }\n\n    _computePortal(poly1, poly2) {\n        for (const edge1 of poly1.edges()) {\n            const edge2 = poly2.touches(edge1);\n            if (edge2 !== null) {\n                return edge1.overlap(edge2);\n            }\n        }\n\n        return null;\n    }\n\n    findPath(from, to, groups = null) {\n        from = _normalizePoint(from);\n        to = _normalizePoint(to);\n\n        const path = this._findPath(from, to, groups);\n        return path && this._funnel(from, to, path);\n    }\n\n    _findPath(from, to, groups = null) {\n        // This is the A* algorithm\n        const fromPoly = this._findClosestPolygon(from, this.fromTolerance, groups);\n        const toPoly = this._findClosestPolygon(to, this.toTolerance, groups);\n\n        if (fromPoly === null || toPoly === null) return null;\n\n        const frontier = new TinyQueue(\n            [{ cost: 0, polygon: fromPoly }],\n            (a, b) => a.cost - b.cost\n        );\n        const cameFrom = { [fromPoly._uuid]: null };\n        const cost = { [fromPoly._uuid]: 0 };\n\n        while (frontier.length) {\n            const current = frontier.pop().polygon;\n\n            if (current._uuid === toPoly._uuid) {\n                break;\n            }\n\n            for (const { polygon: next } of Object.values(current.neighbors)) {\n                if (groups && !groups.includes(next.group)) {\n                    continue;\n                }\n\n                const nextCost =\n                    cost[current._uuid] + this._computeCost(current, next);\n\n                if (\n                    // node not yet visited\n                    !cost.hasOwnProperty(next._uuid) ||\n                    // this path to node has lower cost\n                    nextCost < cost[next._uuid]\n                ) {\n                    frontier.push({\n                        cost: nextCost + this._heuristic(next, toPoly),\n                        polygon: next,\n                    });\n                    cost[next._uuid] = nextCost;\n                    cameFrom[next._uuid] = current;\n                }\n            }\n        }\n\n        return this._reconstructPath(toPoly, cameFrom);\n    }\n\n    _computeDistance(a, b) {\n        return a.centroidDistance(b);\n    }\n\n    _computeCost(a, b) {\n        if (this.costFunc !== null) {\n            const portal = a.neighbors[b._uuid].portal;\n            return this.costFunc(a, b, portal);\n        }\n        return this._computeDistance(a, b);\n    }\n\n    _heuristic(poly, to) {\n        if (poly._uuid == to._uuid) return 0;\n        if (this.heuristicFunc !== null) return this.heuristicFunc(poly, to);\n        return this._computeDistance(poly, to);\n    }\n\n    _findContainingPolygon(point, groups) {\n        const halfQuerySize = this.pointQuerySize / 2;\n        const bounds = {\n            x: point.x - halfQuerySize,\n            y: point.y - halfQuerySize,\n            w: this.pointQuerySize,\n            h: this.pointQuerySize,\n        };\n        for (const poly of this.qt.get(bounds)) {\n            if (poly.polygon.contains(point) && (!groups || groups.includes(poly.polygon.group))) {\n                return poly.polygon;\n            }\n        }\n\n        return null;\n    }\n\n    _findClosestPolygon(point, searchRadius, groups) {\n        if (searchRadius < this.pointQuerySize / 2) {\n            return this._findContainingPolygon(point, groups);\n        }\n\n        let containingPoly = this._findContainingPolygon(point, groups);\n        if (containingPoly) return containingPoly;\n\n        const bounds = {\n            x: point.x - searchRadius / 2,\n            y: point.y - searchRadius / 2,\n            w: searchRadius,\n            h: searchRadius,\n        };\n        let closestDistance = Infinity;\n        let closestPoly = null;\n        for (const poly of this.qt.get(bounds)) {\n            if (!groups || groups.includes(poly.polygon.group)) {\n                let distance = poly.polygon.distanceToPoint(point);\n                if (distance < closestDistance) {\n                    closestPoly = poly;\n                    closestDistance = distance;\n                }\n            }\n        }\n\n        return closestPoly.polygon;\n    }\n\n    _reconstructPath(to, cameFrom) {\n        if (!cameFrom.hasOwnProperty(to._uuid)) {\n            // Disconnected\n            return null;\n        }\n\n        let current = to;\n\n        const path = [];\n        while (current !== null) {\n            path.push(current);\n            current = cameFrom[current._uuid];\n        }\n\n        return path.reverse();\n    }\n\n    /** Funnel algorithm, following https://medium.com/@reza.teshnizi/the-funnel-algorithm-explained-visually-41e374172d2d */\n    _funnel(from, to, path) {\n        if (path.length === 0) {\n            throw new Error(\"Path cannot be empty.\");\n        } else if (path.length === 1) {\n            return [from, to];\n        }\n\n        const tail = [from];\n        const left = [];\n        const right = [];\n\n        // Initialize funnel\n        const initialPortal = path[0].neighbors[path[1]._uuid].portal;\n        left.push(initialPortal.p1);\n        right.push(initialPortal.p2);\n\n        // Iterate over portals\n        for (let i = 1; i < path.length - 1; i++) {\n            const poly = path[i];\n            const nextPoly = path[i + 1];\n            const portal = poly.neighbors[nextPoly._uuid].portal;\n            // The portal end points are in left-to-right order, viewed from the inside of the polygon.\n            this._extendFunnel(tail, left, right, portal.p1, portal.p2);\n        }\n\n        // Close funnel to endpoint\n        this._extendFunnel(tail, left, right, to, to);\n\n        return tail;\n    }\n\n    _extendFunnel(tail, left, right, leftPoint, rightPoint) {\n        // Extend funnel on the left\n        this._extendFunnelSide(tail, left, right, true, leftPoint);\n        // Extend funnel on the right\n        this._extendFunnelSide(tail, left, right, false, rightPoint);\n    }\n\n    _extendFunnelSide(tail, left, right, extendLeft, newPoint) {\n        const apex = tail[tail.length - 1];\n        // We pretend to be in the `expandLeft` case here. Otherwise flip.\n        if (!extendLeft) {\n            [left, right] = [right, left];\n        }\n\n        // If `newPoint` is the end point of the left side of the funnel, skip it.\n        const lastLeft =\n            left.length === 0 ? tail[tail.length - 1] : left[left.length - 1];\n        if (newPoint.equals(lastLeft)) {\n            return;\n        }\n\n        // Determine how far to shrink the funnel\n        let j = this._findFirstLeftOfPoint(\n            apex,\n            left,\n            newPoint,\n            true,\n            !extendLeft\n        );\n        // All points in `left` with index `< j` are right of `newPoint` and\n        // all points in `left` with index `>= j` are left of or at the same angle as `newPoint`.\n        left.length = j; // Shrink funnel if `j < left.length`\n        left.push(newPoint);\n        if (j === 0) {\n            // If the funnel shrunk all the way on the left, it might collapse to the right.\n            // Determine how far it needs to collapse\n            let k = this._findFirstLeftOfPoint(\n                apex,\n                right,\n                newPoint,\n                false,\n                extendLeft\n            );\n            // All points in `right` with index `< k` are left of or at the same angle as `newPoint` and\n            // all points in `right` with index `>= k` are right of `newPoint`.\n            tail.push(...right.splice(0, k)); // Collapse funnel if `k > 0`\n        }\n    }\n\n    /**\n     * Given an array `arr` of points, find the index of the first one that is\n     * on the left side of a given point `p`, viewed from `origin`. If no such\n     * point exists, the length of the list is returned.\n     *\n     * If `flip` is true, find the first that is on the right side instead.\n     *\n     * If `acceptColinear` is true, the returned point may also be colinear.\n     */\n    _findFirstLeftOfPoint(origin, arr, p, acceptColinear, flip) {\n        let i;\n        for (i = 0; i < arr.length; i++) {\n            const found = flip\n                ? this._isInLeftRightOrder(origin, p, arr[i], acceptColinear)\n                : this._isInLeftRightOrder(origin, arr[i], p, acceptColinear);\n            if (found) return i;\n        }\n        return i;\n    }\n\n    /**\n     * Are the points `p1` and `p2` in left-to-right order, viewed from `origin`?\n     * If points are colinear, the value of `acceptColinear` is returned.\n     */\n    _isInLeftRightOrder(origin, p1, p2, acceptColinear = false) {\n        const vec1 = p1.sub(origin);\n        const vec2 = p2.sub(origin);\n        const c = cross(vec1, vec2);\n        return acceptColinear ? c <= 0 : c < 0;\n    }\n\n    /** Returns the points `p1` and `p2` in left-to-right order, viewed from `origin`. */\n    _orderLeftRight(origin, p1, p2) {\n        if (this._isInLeftRightOrder(origin, p1, p2)) {\n            return [p1, p2];\n        } else {\n            return [p2, p1];\n        }\n    }\n}\n","import { Vector, isclose, clip, dot, cross } from \"./math\";\nimport { Edge, Polygon, NavMesh } from \"./navmesh\";\n\nconst Point = Vector;\n\nexport { Point, Vector, isclose, clip, dot, cross, Edge, Polygon, NavMesh };\n"],"sourceRoot":""}